// -*- C++ -*-
/** @name DjVu Reference Library
    @version
    990221
    @author
    Leon Bottou, 02/1999
*/
//@{

//----------------------------------------
/** @name Introduction

    {\bf DjVu Technology} --- Over 90 percent of the information in the world
    is still on paper. Many of those paper documents include color graphics
    and/or photographs that represent significant invested value. And almost
    none of that rich content is on the Internet.  That's because scanning
    such documents and getting them onto a Web site has been problematic at
    best. At the high resolution necessary to preserve the quality of images
    and to keep type readable, file sizes become far too bulky for acceptable
    download speed. Reducing resolution to achieve satisfactory download speed
    means forfeiting quality and legibility. Conventional JPEG and GIF
    compression techniques only begin to solve the problem. As a result, Web
    site content developers have been unable to leverage existing printed
    materials.
    
    The DjVu image compression technology \URL{http://www.djvu.att.com/}
    addresses this problem.  Content developers can scan high-resolution color
    pages of books, magazines, catalogs, manuals, historical or ancient
    documents.  The DjVu document format provides the means to compress these
    bulky images to a size comparable to that of an HTML page.  Content
    providers and consumers around the world can leverage the incredible
    wealth of information and images that were previously trapped in hard copy
    form. DjVu is the enabling technology that will deliver on the promise of
    the Internet as the world's universal library.

    There are in fact three kinds of DjVu image files:
    \begin{description}
    \item[Color DjVu Image] ---
       Color DjVu Image files are best used for encoding photographic images
       in colors or in shades of gray.  The images are coded using the IW44
       wavelet representation optimized for fast progressive rendering.
    \item[Bilevel DjVu Image] ---
       Bilevel DjVu Image files are best used to compress black and white
       images representing text and simple drawings.  The JB2 data compression
       model uses a the "soft pattern matching" technique which essentially
       consists of encoding each character by describing how it differs from a
       well chosen already encoded character.
    \item[Compound DjVu Image] ---
       Compound DjVu Image files are an extremely efficient way to compress
       high resolution color document images containing both pictures and
       text, such as a page of a magazine.  Compound DjVu Images represent the
       document images using two layers.  The {\em background layer} is used
       for encoding the pictures and the paper texture.  The {\em foreground
       layer} is used for encoding the text and the drawings.
   \end{description}
   In addition we often use {\bf IW44 Image} files. This is the native format
   for the IW44 wavelet representation. These files have the same uses then
   Color DjVu Images but use a simpler file format.  There are two variants of
   IW44 files for gray level images and color images.

   {\bf DjVu Reference Library} --- The DjVu Reference Library implements the
   components of the DjVu technology that are essential for the definition of
   the file formats.  AT&T Laboratories \URL{http://www.att.com/attlabs}
   releases the full source code of the DjVu Reference Library under the terms
   of the \Ref{AT&T Source Code License}.
   
   To understand the meaning of this release, it is important to realize that
   the separation of AT&T, NCR and Lucent Technologies has significantly
   changed the business equation.  AT&T is not in the business of selling
   software.  The DjVu technology is interesting for AT&T because it may give
   the means to propose enhanced services to its customers.  This can only
   happen if we ensure that the DjVu technology is widely disseminated.

   This source code release serves three purposes:
   \begin{itemize}
   \item It demonstrates our intention to create a lasting technology.
      Regardless of AT&T involvement, developers around the world now have a
      permanent access to critical parts of DjVu technology.
   \item It allows developers around the world to work with the DjVu
      technology, to create new advances using our basic building blocks, to
      create bridges between DjVu and other document representation formats,
      to create viewers for various platforms, etc.
   \item It provides an authoritative implementation of the DjVu format
      for standardization purposes.
   \end{itemize}

   In the spirit of open source development, the text of the AT&T Source Code
   License makes sure that any work containing or derived from the DjVu
   Reference Library will be available to anyone in source code form.  This is
   to ensure the greatest dissemination of AT&T's technology.  We know however
   that these terms will not fit everyone's needs.  You may contact our
   intellectual property department to setup other agreements on the basis of
   fair revenue sharing.

   The DjVu Reference Library currently contains:
   \begin{itemize}
   \item The {\em DjVu Decoder}, which decodes IW44 and DjVu files into 
         a compact internal data structure (see \Ref{DjVuImage}) which
         can be used to render the image.
   \item The {\em DjVu Rendering Engine}, which uses this data structure
         and produces the pixel representation of any part of the image 
         at any resolution.
   \item The {\em IW44 Wavelet Encoder}, which processes color or gray level
         images and create IW44 Files.
   \item The {\em Bilevel DjVu Encoder Back-end}, which processes structured
         bilevel images (see \Ref{JB2Image}) and creates a file using the JB2
         data compression model.
   \end{itemize}
   We also intend to release the source code for:
   \begin{itemize}
   \item A {\em Viewer for DjVu documents}, which uses the DjVu Decoder and
         the DjVu Rendering Engine in order to provide progressive decoding,
         on-the-fly rendering, etc.
   \item A {\em Simple Encoder for Bilevel DjVu Files}, which processes a
         bitmap image, creates a structured bilevel image, calls the Bilevel
         DjVu Encoder Back-End, and packages the result as a Bilevel DjVu
         File.  
   \end{itemize}

   The DjVu Reference Library however {\em does not contain} certain parts of
   the DjVu technology such as the {\em Lossy Bilevel Encoder} or the {\em
   Background-Foreground Separation}.  These missing parts have no impact on
   the file format. Different implementations are possible and will only make
   the encoder more or less efficient.  There are in fact several reasons for
   not releasing these components now.  The current source code is so
   intricate that it would not help anyone without a huge documentation
   effort.  Furthermore, releasing this code today would negatively affect the
   business of our business partners and eventually reduce the dissemination
   of the DjVu technology.  */
   

//----------------------------------------
/** @name AT&T Source Code License

    NO WARRANTY.
  */
//@{
//@}



//----------------------------------------
/** @name DjVu File Structure

    DjVu files are organized according to the EA IFF85 layout.  Pointers to
    the appropriate reference document are provided in section
    \Ref{IFFByteStream.h}.  IFF files are logically composed of a sequence of
    data {\em chunks}.  Each chunk comes with a four character {\em chunk
    identifier} describing the type of the data stored in the chunk.  A few
    special chunk identifiers, for instance #"FORM"#, are reserved for so
    called {\em composite chunks} containing a sequence of data chunks.  This
    convention effectively provides IFF files with a hierarchical structure.
    Composite chunks are further identified by a {\em secondary chunk
    identifier}.  For convenience, both identifiers are gathered as an
    extended chunk identifier such as #"FORM:DJVU"#.

    The four octets #"AT&T"# may be inserted in front of the IFF compliant
    byte stream.  The decoder simply ignores these four octets when they are
    present.  These four octets are not part of the IFF format and are not
    required components of a valid DjVu file.  Certain versions of MSIE
    incorrectly recognize any IFF file as a Microsoft AIFF sound file.  The
    presence of these four octets prevents this incorrect identification.

    The DjVu specification mandates that the decoder should silently skip
    chunks whose identifier is not recognized.  This mechanism provides a
    backward compatible way to extend the initial format by allocating new
    chunk identifiers.  */
//@{

/** @name DjVu Image Files

    
    {\bf Color DjVu Image} --- Color DjVu Image files are best used for
    encoding photographic images in colors or in shades of gray.  The images
    The data compression model relies on the IW44 wavelet representation.  The
    IW44 decoder is able to quickly perform progressive rendering of any image
    segment using only a small amount of memory.

    Color DjVu files are composed of a single #"FORM:DJVU"# composite chunk.
    This composite chunk always begins with one #"INFO"# chunk describing the
    image size and resolution (see \Ref{DjVuInfo}).  One or more additional
    #"BG44"# chunks contains the image data encoded with the IW44
    representation (see \Ref{IWPixmap} or \Ref{IWBitmap}).  The image size
    specified in the #"INFO"# chunk and the image size specified in the IW44
    data must be equal.

    {\bf Bilevel DjVu Image} --- Bilevel DjVu Image files are used to compress
    black and white images representing text and simple drawings.  These files
    should not be used for encoding heavily dithered bilevel images.  The JB2
    data compression model uses the "soft pattern matching" technique. This
    technique essentially consists of encoding each character by describing
    how it differs from a well chosen already encoded character.

    Bilevel DjVu Files are composed of a single #"FORM:DJVU"# composite chunk.
    This composite chunk always begins with one #"INFO"# chunk describing the
    image size and resolution (see \Ref{DjVuInfo}).  An additional #"Sjbz"#
    chunk contains the bilevel data encoded with the JB2 representation (see
    \Ref{JB2Image}).  The image size specified in the #"INFO"# chunk and the
    image size specified in the IW44 data must be equal.

    {\bf Compound DjVu Image} --- Compound DjVu Files are an extremely
    efficient way to compress high resolution Compound document images
    containing both pictures and text, such as a page of a magazine.  Compound
    DjVu Files represent the document images using two layers.  The {\em
    background layer} is used for encoding the pictures and the paper texture.
    The {\em foreground layer} is used for encoding the text and the drawings.
      
    Compound DjVu Files are composed of a single #"FORM:DJVU"# composite
    chunk.  This composite chunk always begins with one #"INFO"# chunk
    describing the size and the resolution of the image (see \Ref{DjVuInfo}).

    The main component of the foreground layer is a bilevel image named the
    {\em foreground mask}. The size of the foreground mask is equal to the
    size of the DjVu image.  It contains a black-on-white representation of
    the text and the drawings.  This image is encoded in a single #"Sjbz# 
    chunk using the JB2 representation.

    The foreground layer also contains a small color image, the {\em
    foreground color image}, encoded as a single #"FG44"# chunk using the IW44
    representation (see \Ref{IWPixmap} or \Ref{IWBitmap}).  Compound DjVu
    images are rendered by painting the foreground color image on top of the
    background color image using the foreground mask as a stencil.  The size
    of the foreground color image is computed by rounding up the quotient of
    the mask size by an integer sub-sampling factor ranging from 1 to 12.
    Most Compound DjVu Images use a foreground color sub-sampling factor equal
    to 12.  Smaller sub-sampling factors hardly produce better images.

    The background layer is a color image encoded by an arbitrary number of
    #"BG44"# chunks containing successive IW44 refinements (see \Ref{IWPixmap}
    or \Ref{IWBitmap}).  The size of this image is computed by rounding up the
    quotient of the mask size by an integer sub-sampling factor ranging from 1
    to 12.  Most Compound DjVu Images use a background sub-sampling factor
    equal to 3.  Smaller sub-sampling factors are adequate for images with a
    very rich paper texture.  Larger sub-sampling factors are adequate for
    images containing no pictures.

    There are no ordering or interleaving constraints on these chunks except
    that (a) the #"INFO"# chunk must appear first, and (b) the successive
    #"BG44"# refinements must appear with their natural order.  The chunk
    order simply affects the progressive rendering of DjVu images on a web
    browser.  */

/** @name IW44 Image Files
    
    The IW44 Image file format is the native format for the IW44 wavelet
    representation.  The DjVu Reference Library comes with two small programs,
    \Ref{c44} and \Ref{d44}, for encoding and decoding IW44 Files.
    
    {\bf Gray Level IW44 Images} --- Gray Level IW44 Image files are composed
    of a single #"FORM:BM44"# composite chunk.  This composite chunk itself
    contains one or more #"BM44"# chunks containing successive refinements of
    the gray level image (see \Ref{IWBitmap}).
    
    {\bf Color IW44 Images} --- Color IW44 Image files are composed of a
    single #"FORM:PM44"# composite chunk.  This composite chunk itself
    contains one or more #"PM44"# chunks containing successive refinements of
    the color image (see \Ref{IWPixmap}).  */


/** @name Experimental Features.
    
    The DjVu format already delivers extremely high compression ratios.  Yet
    we keep evaluating new ideas and experimenting with new features.  Here is
    a brief description of the various enhancements under evaluation.  We
    intend to update the DjVu Reference Library as soon as we are satisfied
    with such enhancements.

    {\bf Hyper-links} --- We are experimenting with an {\em annotation chunk}
    containing directives for the DjVu image browser, such as hyper-links,
    image placement, border color or default zoom factor.  Such directives
    will most likely be described using an extensible text syntax and stored
    into an #"ANTa"# or #"ANTz"# chunk.

    {\bf Included Files} --- Multiple DjVu files may share information such as
    background layer or character shapes.  There are many benefits associated
    with storing such shared information in separate files.  A well designed
    browser may keep pre-decoded copies of these files in a cache.  This
    procedure would reduce the size of the data transferred over the Internet
    and also increase the display speed.  The currently envisioned scheme
    involves an {\em inclusion chunk} (chunk identifier #"INCL"#) containing
    the URL of a file to include.  The included file would be a #"FORM:DJVI"#
    chunk potentially containing any information otherwise allowed in a DjVu
    file (except for the #"INFO"# chunk of course).  The challenge consists in
    making this system fast enough to hide the cost of an extra round-trip
    between the browser and the web server.

    {\bf Document Navigation} --- Documents can be represented using one DjVu
    file per page. Each DjVu file may contain (or better: may include a file
    containing) a {\em navigation directory chunk} (chunk identifier
    #"NDIR"#). This navigation directory simply lists the URLs of all DjVu
    files composing a document.  Once the DjVu browser knows the document
    structure, it can use smart caching, pre-fetching and pre-decoding
    strategies.

    {\bf Multi-page Files} --- The next step consists in packaging all files in
    a document (i.e. all the pages and all the included files) as a single
    archive file.  Although this is good for archiving or emailing, using a
    single file is not very good for web applications because it does not
    provide a random access to each page.  Web designers would have the choice
    of either (a) unpacking the archive, or (b) use an appropriate Apache
    module or CGI script for unpacking the requested file on the fly.  The
    preferred archive format is a single #"FORM:DJVM"# chunk containing a
    directory (chunk identifier #"DIR0"#) and all the archived files with
    their natural IFF structure.

    {\bf Per-Character Color} --- Color DjVu files represent the colors of the
    text and drawings using a low resolution color image named the foreground
    color image.  We are considering an alternative representation using one
    color for each character (or more specifically, for each mask component).
    This alternative representation would be more appropriate for encoding
    electronically produced documents.

    {\bf Semantic Markups} --- DjVu files already contain a lot of information
    about the structure of the page.  We could create a real {\em multi-valued
    document} by adding a #"DXML"# chunk containing the textual information in
    the page with adequate semantic markups.  The association between the
    textual information and the image would be described by a #"DX2I"# chunk.
    That would finally allow us to do Copy/Paste with DjVu documents.  */
//@}



//----------------------------------------
/** @name Getting Started
 */
//@{

/** @name Compiling the Library (Unix)


    {\bf Directories} --- The structure of the distribution is essentially
    flat.  All the source code files, for both the library and the utility
    programs, are found in the main directory #"libdjvu++"#.  A few
    subdirectories contain accessory material.  Directory #"@Doc"# contains
    the HTML documentation generated from the source files.  Directory
    #"@Samples"# contains sample DjVu files for testing purposes.  Directory
    #"@Test"# contains a few test programs for the library basic features.
    Directory #"@Tools"# contains tools that may be useful for building the
    library or its documentation.


    {\bf Prerequisites} --- The DjVu Reference Library should compile and run
    on any well behaved Unix system, {\em provided that you use a good C++
    compiler} supporting templates, exceptions and possibly multithreading.
    Workstation makers usually provide good compilers.  You can certainly
    compile and run the library with these compilers if you find out which
    options apply to your system and your particular version of the compiler.
    We find that there are just too many different compilers around.  This is
    why we recommend using #gcc# or #egcs#.

    You can safely proceed to the compilation if you have #gcc-2.8.x# or any
    version #egcs# greater than #egcs-1.0.2#.  Use command #g++ -v# to find
    out what is installed on your system.  If you have an earlier version of
    #g++# such as #gcc-2.7.23#, you must upgrade because it is not going to
    work.  We strongly recomment upgrading directly to #egcs-1.1.1# or better.
    The easiest way consists of picking a binary distribution somewhere on the
    Internet.  Linux users may have a look at \URL{http://www.gcc.ml.org} or
    \URL{http://rufus.w3.org/linux/RPM}.

    {\bf Building your compiler (advanced)} --- You should really skip this
    section if you can avoid reading it.  You should only read it if (a) you
    cannot find a suitable binary distribution of #egcs#, or (b) you want to
    experiment with the multi-threading features of the library.

    Building the #egcs# compilers requires GNU Make.  The Linux operating
    systems uses GNU Make by default.  Many Unix systems provide GNU Make
    under the name #gmake#.  You must otherwise download the source code at
    \URL{ftp://gatekeeper.dec.com/pub/GNU/make} or
    \URL{ftp://prep.ai.mit.edu/pub/gnu}, unpack it, read the instructions,
    compile and install.

    You must then download the source distribution of the latest release of
    #egcs# from \URL{http://egcs.cygnus.com}.  We provide a small patch for
    #"egcs/gcc/libgcc2.c"# which is required by our multi-threading code.
    You can apply the patch using command #patch#. 
    \begin{verbatim}
      % cd egcs/gcc
      % patch < $HOME/libdjvu++/@Tools/libgcc2.c.diff
      Patching file libgcc2.c using Plan A...
      Hunk #1 succeeded at 3063.
      Hunk #2 succeeded at 3118.
      done
    \end{verbatim}
    This patch has been tested with #egcs-1.1# and #egcs-1.1.1#.  We hope that
    the EGCS people will either include the patch in their future releases, or
    provide a similar capability.  If anything suspicious happens during the
    patching process, we suggest that you restore the original version of
    #"libgcc2.c"# which is automatically saved as #"libgcc2.c.orig"#.

    You must then configure and compile #egcs#.  Everything is pretty well
    described at \URL{http://egcs.cygnus.com}.  I could use for instance the
    following commands on my SGI workstation running Irix-6.4:
    \begin{verbatim}
      % cd egcs
      % configure --prefix=$HOME/egcs  mips-sgi-irix-5.3
      % gnu-make
      % gnu-make install
    \end{verbatim}
    You are reading correctly: I am pretending that my workstation has
    Irix-5.3 because I want to create backward compatible binaries.  Welcome
    to the wonderful world of compilers.

    {\bf Compiling the DjVu Reference Library} --- Compiling the DjVu
    Reference Library is a two step process.  You must first invoke the script
    #configure# which searches the compiler, selects the compilation options
    and creates the makefiles.
    \begin{verbatim}
       % configure --prefix=$HOME/djvu
    \end{verbatim}

    You can specify a particular compiler by setting environment variable
    #CXX# before invoking the configuration script. This script also 
    supports the following options:
    \begin{description}
    \item[--prefix=PREFIXDIR] indicates where the binary files will be installed.
    \item[--with-debug] enables the debugging options of the compiler.
    \item[--with-cxxflag=FLAG] passes a particular option to the compiler.
    \item[--without-threads] disables multi-threading (the default).
    \item[--with-threads=(cothreads|posix|dce)] enables multithreading and
         selects a multithreading implementation (see \Ref{GThreads.h}). You
         must make sure that your C++ compiler is compatible with the chosen
         thread implementation.  The safest option consists of using the
         patched version of #egcs# (see above) and the #cothreads#
         implementation.
    \end{description}

    You are now ready to compile and install everything by typing:
    \begin{verbatim}
       % make all
       % make install
    \end{verbatim}

    {\bf Using the DjVu Reference Library} --- At this point, you have
    generated a collection of small executables documented in section
    \Ref{Utility Programs}.  This is not very exciting.  It is now time to
    remember that the DjVu Reference Library is a source code library.  Almost
    everything you can use safely is documented in section 
    \Ref{Library Reference}.  You may want however to start with 
    sections \Ref{Decoding DjVu content} and \Ref{Creating DjVu content}.  */


/** @name Compiling the Library (Systems other than Unix)       

   This library compiles without modification under Windows using Visual C++
   version 5.0.  It should also compile under MacOS using the MetroWerks
   compiler, although some system dependent functions are still missing.  In
   both cases however, you have to provide your makefile (or your project, or
   your workspace or whatever) using the Unix makefiles as a template.

 */


/** @name Decoding DjVu content

    See \Ref{DjVuImage.h}.
 */

/** @name Creating DjVu content

    See \Ref{djvumake}.
 */


//@}



//----------------------------------------
/** @name Library Reference
 */             

//@{
//@Include: DjVuGlobal.h
//@Include: GException.h
//@Include: GSmartPointer.h
//@Include: GString.h
//@Include: GContainer.h
//@Include: GRect.h
//@Include: GThreads.h
//@Include: GOS.h
//@Include: ByteStream.h
//@Include: IFFByteStream.h
//@Include: ZPCodec.h
//@Include: BSByteStream.h
//@Include: GBitmap.h
//@Include: GPixmap.h
//@Include: GScaler.h
//@Include: IWImage.h
//@Include: JB2Image.h
//@Include: DjVuImage.h
//@}


/** @name Utility Programs
 */             

//@{
//@Include: bzz.cpp
//@Include: djvuinfo.cpp
//@Include: ppmcoco.cpp
//@Include: c44.cpp
//@Include: d44.cpp
//@Include: djvutopnm.cpp
//@Include: djvumake.cpp
//@Include: djvuextract.cpp
//@}


//@}
