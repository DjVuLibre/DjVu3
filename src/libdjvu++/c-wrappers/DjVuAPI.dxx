// -*- C++ -*-
/** @name DjVu C API Libraries

    Copyright (c) LizardTech 2000.
    All Rights Reserved.  

    This software may only be used by you under license from LizardTech
    Inc. ("LizardTech"). A copy of the license should have been packaged
    with this software.  If you received this software without first
    entering into a license with LizardTech, you have an infringing copy of
    this software and cannot use it without violating LizardTech's intellectual
    property rights.

    {\bf Acknowledgements} -- The DjVu API is the results of the
    work of the whole DjVu team, which includes researchers,
    developers, contractors, webmasters, marketing, testers, and 
    even a few lawyers.  The \URL[DjVu Credits]{djvucredits.html} 
    lists the key contributors to these libraries and utilities.
    @version
    3.0
    @author
    Bill C Riemers <bcr@lizardtech.com>,  L\'eon Bottou, Parag Deshmukh
*/
//@{





//----------------------------------------
/** @name Introduction

    {\bf DjVu Technology} --- Over 90 percent of the information in the world
    is still on paper. Many of those paper documents include color graphics
    and/or photographs that represent significant invested value. And almost
    none of that rich content is on the Internet.  That's because scanning
    such documents and getting them onto a Web site has been problematic at
    best. At the high resolution necessary to preserve the quality of images
    and to keep type readable, file sizes become far too bulky for acceptable
    download speed. Reducing resolution to achieve satisfactory download speed
    means forfeiting quality and legibility. Conventional JPEG and GIF
    compression techniques only begin to solve the problem. As a result, Web
    site content developers have been unable to leverage existing printed
    materials.
    
    The DjVu image compression technology \URL{http://www.djvu.com/}
    addresses this problem.  Content developers can scan high-resolution color
    pages of books, magazines, catalogs, manuals, historical or ancient
    documents.  The DjVu document format provides the means to compress these
    bulky images to a size comparable to that of an HTML page.  Content
    providers and consumers around the world can leverage the incredible
    wealth of information and images that were previously trapped in hard copy
    form. DjVu is the enabling technology that will deliver on the promise of
    the Internet as the world's universal library.

    There are in fact three kinds of DjVu image files:
    \begin{description}
    \item[Photo DjVu Image.]
       Photo DjVu Image files are best used for encoding photographic images
       in colors or in shades of gray.  The images are coded using the IW44
       wavelet representation optimized for fast progressive rendering.
    \item[Bitonal DjVu Image.]
       Bitonal DjVu Image files are best used to compress black and white
       images representing text and simple drawings.  The JB2 data compression
       model uses a the "soft pattern matching" technique which essentially
       consists of encoding each character by describing how it differs from a
       well chosen already encoded character.
    \item[Compound DjVu Image.]
       Compound DjVu Image files are an extremely efficient way to compress
       high resolution color document images containing both pictures and
       text, such as a page of a magazine.  Compound DjVu Images represent the
       document image using two layers.  The {\em background layer} is used
       for encoding the pictures and the paper texture.  The {\em foreground
       layer} is used for encoding the text and the drawings.
   \end{description}
   In addition we often use {\bf IW44 Image} files. This is the native format
   for the IW44 wavelet representation. These files have the same uses then
   Photo DjVu Images but use a simpler file format.  There are two variants of
   IW44 files for gray level images and color images.

  {\bf DjVu Reference Library} --- The #DjVu Reference Library# implements the
  components of the DjVu technology that are essential for the definition of
  the file formats.  LizardTech \URL{http://www.lizardtech.com}
  releases the full source code of the #DjVu Reference Library# under the terms
  of the \Ref{LizardTech Source Code License}.

  {\bf DjVu Software Development Kit (SDK)} --- The DjVu SDK defines
  a C interface designed to allow manipulations of multi-page DjVu
  documents, import and export of some of the most common formats into
  DjVu.

  Our experience has been there are two different categories of use for
  DjVu code:  Multi-threaded code for interactive viewing of documents,
  and single threaded code that needs to compress documents.
  The {\bf DjVu Reference Library} is very well suited for multi-threaded 
  GUI code.  The DjVu SDK is designed for the latter case.  Even with
  programs like DjVu Shop which do both, it still greatly simplies
  the source code to keep the compression and rendering tasks separate.

  For most uses of the DjVu SDK, simple shell scripts would
  suffice.  The DjVu 0.9 release, which is still our benchmark
  for quality, was primarily based on shell scripts.  Users had complete
  control of the DjVu compressions and could easily customize the
  code to work the way they needed it to.
  With the DjVu 2.0 release all the shell scripts were replaced with
  C programs and API calls.  This greatly improved the reliability and
  speed of DjVu compression.  However, customization of code become
  very difficult even for professional programmers.

  The DjVu 3.0 release attempts to merge the best features of the
  previous DjVu releases to allow advanced programers and users
  to customize nearly everything, while still having a stable C interface
  to work from.  This is accomplished by first by separating the API
  into five primary interfaces:

  \begin{description}
  \item[DjVu Multi-Page API.]
    As defined in \Ref{DjVuMultiAPI.h}, this provides a C interface for
    manipulating multi-page documents.  The \Ref{djvubundle utility} and
    the \Ref{djvujoin utility} are simple command line implementations of
  the {\bf DjVu Multi-Page API}.
  \item[DjVu Decode API.]
    As defined in \Ref{DjVuDecodeAPI.h}, this provides a C interface for
    exporting DjVu documents to other graphic formats.
    The \Ref{djvudecode utility} and other decoding programs are
    implementations of the {\bf DjVu Decode API}.  For GUI programs designed
    to display DjVu documents, we recommend using the
    {\bf DjVu Reference Library}.  
  \item[DjVu Bitonal API.]
    As defined in \Ref{DjVuBitonalAPI.h}, this provides a C interface for
    converting files to {\bf Bitonal DjVu Image} documents.
    The \Ref{bitonaltodjvu utility} is a simple command line implementation of
    this API.
  \item[DjVu Photo API.]
    As defined in \Ref{DjVuPhotoAPI.h}, this provides a C interface for
    converting files to {\bf Photo DjVu Image} documents.
    The \Ref{phototodjvu utility} is a simple command line implementation of
    this API.
  \item[DjVu Document API.]
    As defined in \Ref{DjVuDocumentAPI.h}, this provides a C interface for
    converting files to {\bf Compound DjVu Image} documents.
    The \Ref{documenttodjvu utility} is a simple command line implementation
    of this API.
  \end{description}

  Using the five primary API's it is possible to implement all the SDK utilities
  except {\bf djvureindex}.  The functionality neccissary for {\bf djvureindex}
  is not included to discourage usage of the old multi-page format.
  However, programmers often need to do program things that can not
  be easily or efficiently done with a script.  For example, maybe they wish
  to read the image from a database server, instead of from a file on
  the local disk.  Or perhaps they wish to decode an image directly to
  an image buffer, instead of having to read the image off of disk in
  a different format.  To serve for these special needs, we found it
  neccissary to define two more API's that can be used to enhance the
  five primary API's:

  \begin{description}
  \item[DjVuAPI]
  As defined in \Ref{DjVuAPI.h}, this API defines the neccessary functions
  and structures needed to do memory and callback operations with the
  \Ref{DjVuDecodeAPI.h}, \Ref{DjVuBitonalAPI.h}, \Ref{DjVuPhotoAPI.h},
  and \Ref{DjVuDocumentAPI.h}.
  \item[DjVu Global API]
  As defined in \Ref{DjVu.h}, the global API defines functions for 
  memory overloads, progress monitoring, and command line/configuration
  file parsing.
  \end{description}

  With all seven API's, we have addressed all the major problems facing
  a DjVu application developer except one.  How do we allow the 
  developer complete control over processes like image segmentation 
  which requires approximately 40 separate variable settings to be
  tuned properly without requiring the DjVu application developer
  understanding exactly what each variable does and what settings the
  the end user of the application will need?  Even members of the DjVu
  development team do not know the effects of all the configuration
  options can have when used together, in a previously untried combination.

  The answer to this perplexing problem was to introduce profiles.  Old
  fortran programs can think of these as datacards, and young C programmers
  can thing of them as Makefiles.  Regardless of how you prefer to think
  of them, the idea is simple.  A \URL[profile]{../djvuprofile.html} defines
  a commonly used set of options.  Instead of specifying all the options
  in a command line argument, or argv[] vector, it is sufficient just to
  specify the profile name that contains all the options.  
*/
  
//----------------------------------------
/** @name DjVu File Structure

    DjVu files are organized according to the ``EA IFF 85'' layout.  Pointers to
    the appropriate reference document are provided in section
    \Ref{IFFByteStream.h}.  IFF files are logically composed of a sequence of
    data {\em chunks}.  Each chunk comes with a four character {\em chunk
    identifier} describing the type of the data stored in the chunk.  A few
    special chunk identifiers, for instance #"FORM"#, are reserved for so
    called {\em composite chunks} containing a sequence of data chunks.  This
    convention effectively provides IFF files with a hierarchical structure.
    Composite chunks are further identified by a {\em secondary chunk
    identifier}.  For convenience, both identifiers are gathered as an
    extended chunk identifier such as #"FORM:DJVU"#.

    The four octets #"AT&T"# may be inserted in front of the IFF compliant
    byte stream.  The decoder simply ignores these four octets when they are
    present.  These four octets are not part of the IFF format and are not
    required components of a valid DjVu file.  Certain versions of MSIE
    incorrectly recognize any IFF file as a Microsoft AIFF sound file.  The
    presence of these four octets prevents this incorrect identification.

    The DjVu specification mandates that the decoder should silently
    skip chunks whose identifier is not recognized.  This mechanism
    provides a backward compatible way to extend the initial format by
    allocating new chunk identifiers. 

    Further information about the DjVu file format is available in 
    the \Ref{DjVu Reference Library}. 
*/
//@{

/** @name Multipage DjVu documents.

    The DjVu3 system supports two models for multi-page documents:
    {\em bundled} multi-page documents and {\em indirect} multi-page documents.
    The multi-page API allows you to assemble already compressed pages and to
    create multipage DjVu documents using either model.
    
    {\bf Bundled multi-page documents} --- A {\em bundled} multi-page DjVu
    document uses a single file to represent the entire document.  This single
    file contains all the pages as well as ancillary information (e.g. the
    page directory, data shared by several pages, thumbnails, etc.).  Using a
    single file format is very convenient for storing documents or for sending
    email attachments.

    A bundled multi-page document is composed of a single #"FORM:DJVM"#
    composite chunk.  This composite chunk always begins with a #"DIRM"# chunk
    containing the document directory (see. \Ref{DjVmDir.h}) which represents
    the list of the {\em component files} that compose the document.  The
    component files themselves are then encoded as IFF85 composite chunks
    following the #"DIRM"# chunk.
    \begin{itemize}
    \item  
       Component files may be any valid DjVu image (see \Ref{DjVu Image Files})
       or IW44 image (see \Ref{IW44 Image Files}.)  These component files 
       always represent a page of a document.  The corresponding IFF85 chunk ids are 
       #"FORM:DJVU"#, #"FORM:PM44"#, or #"FORM:BM44"#.
    \item 
       Component files may contain shared information indirectly referenced by
       some document pages.  These {\em shared component files} are always composed
       of a single #"FORM:DJVI"# chunk containing an arbitrary collection of
       chunks. 
    \item
       Thumbnail files contain optional thumbnail images for a few consecutive
       pages of the document.  Thumbnail files consist of a single
       #"FORM:THUM"# composite chunk containing several #"TH44"# chunks
       containing IW44 encoded thumbnail images (see \Ref{IWImage.h}).  These
       thumbnails always pertain the first few page files following the
       thumbnail file in the document directory.
    \end{itemize}

    {\bf Including shared information} --- Any DjVu image file contained in a
    multipage file may contain an #"INCL"# chunk containing the ID of a shared
    component file.  The decoder should then process the chunks contained in
    the shared component file as if they were contained by the DjVu image
    file.  The shared component file may potentially containing any
    information otherwise allowed in a DjVu image file (except for the
    #"INFO"# chunk of course). There are many benefits associated with storing
    such shared information in separate files.  A well designed browser may
    keep pre-decoded copies of these files in a cache.  This procedure would
    reduce the size of the data transferred over the Internet and also
    increase the display speed.  The multipage DjVu compressor, for instance,
    identifies similar object shapes occuring in several pages.  These shapes
    are encoded in a shape dictionary (chunk #"Djbz"#) placed in a shared
    component file.  All relevant pages include this shared component file.
    Although they appear in several pages, these shared shapes are encoded
    only once in the document.

    {\bf Browsing a multi-page document} --- You can view the pages using the
    DjVu plugin and a web browser.  When you type the URL of a multi-page
    document, the browser starts downloading the whole file, but displays the
    first page as soon as it is available.  You can immediately navigate to
    other pages using the DjVu toolbar.  Suppose however that the document is
    stored on a remote web server.  You can easily access the first page and
    see that this is not the document you wanted.  Although you will never
    display the other pages the browser is transferring data for these pages
    and is wasting the bandwith of your server (and the bandwith of the
    Internet too).  You could also see the summary of the document on the
    first page and jump to page 100.  But page 100 cannot be displayed until
    data for pages 1 to 99 has been received.  You may have to wait for the
    transmission of unnecessary page data.  This second problem (the
    unnecessary wait) can be solved using the ``byte serving'' options of the
    HTTP/1.1 protocol.  This option has to be supported by the web server, the
    proxies, the caches and the browser.  We are coming there but not quite
    yet.  Byte serving however does not solve the first problem (the waste of
    bandwith).

    {\bf Indirect multi-page documents} --- DjVu solves both problem using a
    special multi-page format named the {\em indirect} model.  An indirect
    multi-page DjVu document is composed of several files.  The main file is
    named the {\em index file}.  You can browse a document using the URL of
    the index file, just like you do with a bundled multi-page document.  The
    index file however is very small.  It simply contains the document
    directory and the URLs of secondary files containing the page data.  When
    you browse an indirect multi-page document, the browser only accesses data
    for the pages you are viewing.  This can be done at a reasonable speed
    because the browser maintains a cache of pages and sometimes pre-fetches a
    few pages ahead of the current page.  This model uses the web serving
    bandwith much more effectively.  It also eliminates unnecessary delays
    when jumping ahead to pages located anywhere in a long document.

    {\bf Obsolete Formats} --- The library also supports two other multipage
    formats which are now obsolete.  These formats are technologically
    inferior and should no longer be used. */

//@}


//----------------------------------------
/** @name DjVu C API Header Files
 */             

//@{
//@Include: DjVu.h
//@Include: DjVuAPI.h
//@Include: DjVuMultiAPI.h
//@Include: DjVuDecodeAPI.h
//@Include: DjVuBitonalAPI.h
//@Include: DjVuPhotoAPI.h
//@Include: DjVuDocumentAPI.h

//@}


/** @name SDK Programs
 */             

//@{
/** @name bitonaltodjvu utility
  @memo The \URL[bitonaltodjvu]{../SDKTools/bitonaltodjvu.html} utility uses
  the API defined in \Ref{DjVuBitonalAPI.h} to perform bitonal to 
  DjVu compressions.
*/
/** @name djvubundle utility
  @memo The \URL[djvubundle]{../SDKTools/djvubundle.html} utility uses
  the API defined in \Ref{DjVuMultiAPI.h} to bundle DjVu
  files together.
*/
/** @name djvudecode utility
  @memo The \URL[djvudecode]{../SDKTools/djvudecode.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to image file(s).
*/
/** @name djvujoin utility
  @memo The \URL[djvujoin]{../SDKTools/djvujoin.html} utility uses
  the API defined in \Ref{DjVuMultiAPI.h} to join DjVu
  files with an index file.
*/
/** @name djvureindex utility
  @memo The \URL[djvureindex]{../SDKTools/djvureindex.html} utility
  uses direct C++ calls to convert old style multi-page
  documents into new style multi-page documents.
*/
/** @name djvutobitonal utility
  @memo The \URL[djvutobitonal]{../SDKTools/djvutobitonal.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to bitonal formats.
*/
/** @name djvutobmp utility
  @memo The \URL[djvutobmp]{../SDKTools/djvutobmp.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to bmp file(s).
*/
/** @name djvutojpeg utility
  @memo The \URL[djvutojpeg]{../SDKTools/djvutojpeg.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to jpeg file(s).
*/
/** @name djvutopbm utility
  @memo The \URL[djvutopbm]{../SDKTools/djvutopbm.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to pbm file(s).
*/
/** @name djvutopict utility
  @memo The \URL[djvutopict]{../SDKTools/djvutopict.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to pict file(s).
*/
/** @name djvutopnm utility
  @memo The \URL[djvutopnm]{../SDKTools/djvutopnm.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to pnm file(s).
*/
/** @name djvutops utility
  @memo The \URL[djvutops]{../SDKTools/djvutops.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to ps file(s).
*/
/** @name djvutotiff utility
  @memo The \URL[djvutotiff]{../SDKTools/djvutotiff.html} utility
  uses the API defined in \Ref{DjVuDecodeAPI.h} to decode single
  and multi-page DjVu files to tiff file(s).
*/
/** @name documenttodjvu utility
  @memo The \URL[documenttodjvu]{../SDKTools/documenttodjvu.html} utility uses
  the the API defined in \Ref{DjVuDocumentAPI.h} to perform document to 
  DjVu compressions.
*/
/** @name phototodjvu utility
  @memo The \URL[phototodjvu]{../SDKTools/phototodjvu.html} utility uses
  the API defined in \Ref{DjVuPhotoAPI.h} to perform photo to 
  DjVu compressions.
*/
//@}

