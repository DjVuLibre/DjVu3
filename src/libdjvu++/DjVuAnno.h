//C-  -*- C++ -*-
//C-
//C- Copyright (c) 1999 AT&T Corp.  All rights reserved.
//C-
//C- This software may only be used by you under license from AT&T
//C- Corp. ("AT&T"). A copy of AT&T's Source Code Agreement is available at
//C- AT&T's Internet website having the URL <http://www.djvu.att.com/open>.
//C- If you received this software without first entering into a license with
//C- AT&T, you have an infringing copy of this software and cannot use it
//C- without violating AT&T's intellectual property rights.
//C-
//C- $Id: DjVuAnno.h,v 1.1.2.2 1999-04-26 19:19:21 eaf Exp $

#ifndef _DJVUANNO_H
#define _DJVUANNO_H


/** @name DjVuImage.h

    Files #"DjVuImage.h"# and #"DjVuImage.cpp"# implement the main interface
    for decoding and rendering DjVu Images or IW44 Images.  Class
    \Ref{DjVuImage} is the central component of this interface.  This class
    provides a decoding function and a few rendering functions.  Display
    programs can call the decoding function from a separate thread.  The user
    interface thread may call the rendering functions at any time.  Rendering
    will be performed using the most recent data generated by the decoding
    thread.  This multithreaded capability enables progressive display of
    remote images.  Program \Ref{djvutopnm} illustrates how class #DjVuImage#
    can be used by a single threaded decoder.  This program first calls the
    decoding function and then renders the desired segment of the image.

    {\bf Creating DjVu images} --- Class \Ref{DjVuImage} does not provide a
    direct way to create a DjVu image.  The recommended procedure consists of
    directly writing the required chunks into an \Ref{IFFByteStream} as
    demonstrated in program \Ref{djvumake}.  Dealing with too many encoding
    issues (such as chunk ordering and encoding quality) would indeed make the
    decoder unnecessarily complex.

    {\bf ToDo: Plugin annotations} --- Class DjVuAnno should move into another
    set of source files in order to implement the annotation chunk parser, and
    to retrieve the hyperlink data structure given a position (x,y).
 
    {\bf ToDo: Multi-page Documents} --- The proposed multi-page format for
    DjVu documents may considerably change the decoding interface for this
    class.  The responsibility of supervising the decoding tasks will be
    transferred to a new class DjVuDocument.  Individual streams composing the
    multi-page document will be processed by a new class DjVuFile.  Class
    DjVuImage will still contain the rendering function, but the DjVu image
    components will be accessed via pointers to the underlying DjVuFile
    objects.
    
    {\bf ToDo: Layered structure} --- Class #DjVuImage# currently contains an
    unstructured collection of smart pointers to various data structures.
    Although it simplifies the rendering routines, this choice does not
    reflect the layered structure of DjVu images and does not leave much room
    for evolution.  We should be able to do better.

    @memo
    Decoding DjVu and IW44 images.
    @author
    L\'eon Bottou <leonb@research.att.com>
    @version
    #$Id: DjVuAnno.h,v 1.1.2.2 1999-04-26 19:19:21 eaf Exp $# */
//@{


#ifdef __GNUC__
#pragma interface
#endif

#include "GString.h"
#include "GThreads.h"
#include "GSmartPointer.h"
#include "ByteStream.h"
#include "DjVuGlobal.h"
#include "GHLObjects.h"
#include "GPContainer.h"

/** Display annotation component.
    The annotation chunk contains directives for displaying DjVu image, such
    as hyperlinks, border color, centering, preferred zoom factor, etc.
    Directives are encoded in plain text using a lisp like syntax.
    
    {\bf Todo} --- The decoding/encoding functions should actually
    convert the annotation chunk into/from an abstract representation
    of the hyperlinks and display modes.  */

class DjVuAnno : public GPEnabled
{
public:
   enum { MODE_UNSPEC=0, MODE_COLOR, MODE_FORE, MODE_BACK, MODE_BW };
   enum { ZOOM_STRETCH=-4, ZOOM_ONE2ONE=-3, ZOOM_WIDTH=-2,
	  ZOOM_PAGE=-1, ZOOM_UNSPEC=0 };
   enum { ALIGN_UNSPEC=0, ALIGN_LEFT, ALIGN_CENTER, ALIGN_RIGHT,
	  ALIGN_TOP, ALIGN_BOTTOM };
   u_int32	bg_color;
   int		zoom;
   int		mode;
   int		hor_align, ver_align;
   GPList<GHLRect>	rect_hlinks;
   GPList<GHLPoly>	poly_hlinks;
   GPList<GHLOval>	oval_hlinks;
   
   /** Constructs an empty annotation object. */
   DjVuAnno();
   virtual ~DjVuAnno();
   /** Decode an annotation chunk.  The annotation data is simply read from
       ByteStream #bs# until reaching an end-of-stream marker.  This function
       is normally called after a call to \Ref{IFFByteStream::get_chunk}. */
   void decode(ByteStream &bs);
   /** Same as \Ref{decode}() but adds the new data to one that has
       been decoded before */
   void merge(ByteStream & bs);
   /** Encodes the annotation chunk.  The annotation data is simply written
       into ByteStream #bs# with no IFF header. This function is normally
       called after a call to \Ref{IFFByteStream::put_chunk}. */
   void encode(ByteStream &bs);
   /** Returns the number of bytes needed by this data structure. */
   unsigned int get_memory_usage() const;
   /** Encodes data back into raw annotation data */
   GString encode_raw(void) const;

   /** Returns TRUE if no features are specified */
   bool		is_empty(void) const;
   
   GString raw;
private:
   GCriticalSection class_lock;

   void		decode(class GLParser & parser);
   
   static GString	read_raw(ByteStream & str);
   
   static u_int32	cvt_color(const char * color, u_int32 def);
   static unsigned char	decode_comp(char ch1, char ch2);
   static u_int32	get_bg_color(class GLParser & parser);
   static int		get_zoom(class GLParser & parser);
   static int		get_mode(class GLParser & parser);
   static int		get_hor_align(class GLParser & parser);
   static int		get_ver_align(class GLParser & parser);
   static void		get_hlinks(class GLParser & parser,
				   GPList<GHLRect> &,
				   GPList<GHLPoly> &,
				   GPList<GHLOval> &);
   static void		del_all_items(const char * name, class GLParser & parser);
};


//@}

// ----- THE END
#endif
