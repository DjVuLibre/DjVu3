//C-  -*- C++ -*-
//C-
//C- Copyright (c) 1999 AT&T Corp.  All rights reserved.
//C-
//C- This software may only be used by you under license from AT&T
//C- Corp. ("AT&T"). A copy of AT&T's Source Code Agreement is available at
//C- AT&T's Internet website having the URL <http://www.djvu.att.com/open>.
//C- If you received this software without first entering into a license with
//C- AT&T, you have an infringing copy of this software and cannot use it
//C- without violating AT&T's intellectual property rights.
//C-
//C- $Id: cjb2.cpp,v 1.2 2000-02-14 22:41:44 leonb Exp $


/** @name cjb2

    {\bf Synopsis}
    \begin{verbatim}
        cjb2 [options] <inputpbmfile>  <outputdjvufile>
    \end{verbatim}
    This simple bilevel encoder demonstrates the major operations for creating
    a Bilevel DjVu Image.  is able to perform lossless encoding and limited
    lossy encoding.  Its purpose is to demonstrate how to generate Bilevel
    DjVu Images and encourage research in pattern matching and halftone
    processing.

    Options are:
    \begin{description}
    \item[-dpi xxx]  Specify image resolution (default 300).
    \item[-smooth]   Smooth characters shapes (lossy).
    \item[-clean]    Clean small flyspecs (lossy).
    \item[-loose]    Substitute patterns with small variations (lossy).
    \end{description}
    Encoding is lossless unless one or several lossy options are selected.
    
    @memo
    Simple JB2 encoder.
    @author
    L\'eon Bottou <leonb@research.att.com>
    @version
    #$Id: cjb2.cpp,v 1.2 2000-02-14 22:41:44 leonb Exp $# */
//@{
//@}


#include "DjVuGlobal.h"
#include "GException.h"
#include "GSmartPointer.h"
#include "GContainer.h"
#include "ByteStream.h"
#include "IFFByteStream.h"
#include "GRect.h"
#include "GBitmap.h"
#include "JB2Image.h"
#include "DjVuInfo.h"




#ifndef IMPLEMENT_MAIN
// Define IMPLEMENT_MAIN to zero before including this file
#define IMPLEMENT_MAIN 1
#endif






// --------------------------------------------------
// UTILITIES
// --------------------------------------------------

#ifdef MIN
#undef MIN
#endif

inline int 
MIN(int a, int b) 
{ 
  return ( a<b ?a :b); 
}

#ifdef MAX
#undef MAX
#endif

inline int 
MAX(int a, int b) 
{ 
  return ( a>b ?a :b); 
}






// --------------------------------------------------
// CONNECTED COMPONENT ANALYSIS - SMOOTH/CLEAN
// --------------------------------------------------

// -- A run of black pixels
struct Run    
{ 
  int y;         // vertical coordinate
  short x1;      // first horizontal coordinate
  short x2;      // last horizontal coordinate
  int ccid;      // component id
};

// -- A component descriptor
struct CC    
{
  GRect bb;      // bounding box
  int npix;      // number of black pixels
  int nrun;      // number of runs
  int frun;      // first run in cc ordered array of runs
  bool special;  // generated by merge_and_split_ccs
};
  

// -- An image composed of runs
class CCImage 
{
public:
  int height;            // Height of the image in pixels
  int width;             // Width of the image in pixels
  GTArray<Run> runs;     // array of runs
  GTArray<CC>  ccs;      // Array of component descriptors
  int largesize;         // CCs larger than that are special
  int smallsize;         // CCs smaller than that are special 
  int tinysize;          // CCs smaller than that may be removed 
  CCImage(int width, int height, int dpi);
  void add_single_run(const int y, const int x1, const int x2, const int ccid=0);
  void add_bitmap_runs(const GBitmap &bm, const int offx=0, const int offy=0, const int ccid=0);
  GP<GBitmap> get_bitmap_for_cc(int ccid) const;
  GP<JB2Image> get_jb2image() const;
  void make_ccids_by_analysis();
  void make_ccs_from_ccids();
  void erase_tiny_ccs();
  void merge_and_split_ccs();
  void smooth_ccs();
  void sort_in_reading_order(); 
};


// -- Compares runs
static inline bool
operator <= (const Run &a, const Run &b)
{
  return (a.y<b.y) || (a.y==b.y && a.x1<=b.x1);
}


// -- Constructs CCImage and provide defaults
CCImage::CCImage(int width, int height, int dpi)
  :height(height), width(width)
{
  // Compute cleaning constants
  int dpi = MAX(200, MIN(900, dpi));
  largesize = MIN( 500, MAX(64, dpi));
  smallsize = MAX(2, dpi/150);
  tinysize = MAX(0, dpi*dpi/20000 - 1);
}


// -- Adds a run to the CCImage
inline void 
CCImage::add_single_run(int y, int x1, int x2, int ccid)
{
  int index = runs.hbound();
  runs.touch(++index);
  Run& run = runs[index];
  run.y = y;
  run.x1 = x1;
  run.x2 = x2;
  run.ccid = ccid;
}


// -- Adds runs extracted from a bitmap
void 
CCImage::add_bitmap_runs(const GBitmap &bm, int offx, int offy, int ccid)
{
  // Iterate over rows
  for (unsigned int y=0; y<bm.rows(); y++)
    {
      const unsigned char *row = bm[y];
      int w = bm.columns();
      int x = 0;
      // Iterate over runs
      while (x < w)
        {
          while (x < w  && !row[x]) x++;
          if (x < w)
            {
              int x1 = x;
              while (x < w && row[x]) x++;
              add_single_run(offy+y, offx+x1, offx+x-1, ccid);
            }
        }
    }
}


// -- Performs connected component analysis
void
CCImage::make_ccids_by_analysis()
{
  // Sort runs
  runs.sort();
  // Single Pass Connected Component Analysis (with unodes)
  int n;
  int p=0;
  GTArray<int> umap;
  for (n=0; n<=runs.hbound(); n++)
    {
      int y = runs[n].y;
      int x1 = runs[n].x1 - 1;
      int x2 = runs[n].x2 + 1;
      int id = (umap.hbound() + 1);
      // iterate over previous line runs
      for(;runs[p].y < y-1;p++);
      for(;(runs[p].y < y) && (runs[p].x1 <= x2);p++ )
        {
          if ( runs[p].x2 >= x1 )
            {
              // previous run touches current run
              int oid = runs[p].ccid;
              while (umap[oid] < oid)
                oid = umap[oid];
              if ((int)id > umap.hbound()) {
                id = oid;
              } else if (id < oid) {
                umap[oid] = id;
              } else {
                umap[id] = oid;
                id = oid;
              }
              // freshen previous run id
              runs[p].ccid = id;
              // stop if previous run goes past current run
              if (runs[p].x2 >= x2)
                break;
            }
        }
      // create new entry in umap
      runs[n].ccid = id;
      if (id > umap.hbound())
        {
          umap.touch(id);
          umap[id] = id;
        }
    }
  // Update umap and ccid
  for (n=0; n<=runs.hbound(); n++)
    {
      Run &run = runs[n];
      int ccid = run.ccid;
      while (umap[ccid] < ccid)
      {
        ccid = umap[ccid];
      }
      umap[run.ccid] = ccid;
      run.ccid = ccid;
    }
}


// -- Constructs the ``ccs'' array from run's ccids.
void
CCImage::make_ccs_from_ccids()
{
  int n;
  Run *pruns = runs;

  // Find maximal ccid
  int maxccid = -1;
  for (n=0; n<=runs.hbound(); n++)
    if (pruns[n].ccid > maxccid)
      maxccid = runs[n].ccid;
  GTArray<int> armap(0,maxccid);
  int *rmap = armap;
  
  // Renumber ccs 
  for (n=0; n<=maxccid; n++)
    armap[n] = -1;
  for (n=0; n<=runs.hbound(); n++)
    if (pruns[n].ccid >= 0)
      rmap[ pruns[n].ccid ] = 1;
  int nid = 0;
  for (n=0; n<=maxccid; n++)
    if (rmap[n] > 0)
      rmap[n] = nid++;
  
  // Prepare cc descriptors
  ccs.resize(0,nid-1);
  for (n=0; n<nid; n++)
    ccs[n].nrun = 0;
  
  // Relabel runs
  for (n=0; n<=runs.hbound(); n++)
    {
      Run &run = pruns[n];
      if (run.ccid < 0) continue;  // runs with negative ccids are destroyed
      int oldccid = run.ccid;
      int newccid = rmap[oldccid];
      CC &cc = ccs[newccid];
      cc.special = false;
      run.ccid = newccid;
      cc.nrun += 1;
    }
  
  // Compute positions for runs of cc
  int frun = 0;
  for (n=0; n<nid; n++) 
    {
      ccs[n].frun = rmap[n] = frun;
      frun += ccs[n].nrun;
    }
  
  // Copy runs
  GTArray<Run> rtmp;
  rtmp.steal(runs);
  Run *ptmp = rtmp;
  runs.resize(0,frun-1);
  pruns = runs;
  for (n=0; n<=rtmp.hbound(); n++)
    {
      int id = ptmp[n].ccid;
      if (id < 0) continue;
      int pos = rmap[id]++;
      pruns[pos] = ptmp[n];
    }

  // Finalize ccs
  for (n=0; n<nid; n++)
    {
      CC &cc = ccs[n];
      cc.special = false;
      runs.sort(cc.frun, cc.frun+cc.nrun-1);
      int npix = 0;
      Run *run = &pruns[cc.frun];
      int xmin = run->x1;
      int xmax = run->x2;
      int ymin = run->y;
      int ymax = run->y;
      for (int i=0; i<cc.nrun; i++, run++)
        {
          if (run->x1 < xmin)  xmin = run->x1;
          if (run->x2 > xmax)  xmax = run->x2;
          if (run->y  < ymin)  ymin = run->y;
          if (run->y  > ymax)  ymax = run->y;
          npix += run->x2 - run->x1 + 1;
        }
      cc.npix = npix;
      cc.bb.xmin = xmin;
      cc.bb.ymin = ymin;
      cc.bb.xmax = xmax + 1;
      cc.bb.ymax = ymax + 1;
    }
}


// Removes ccs which are too small.
void
CCImage::erase_tiny_ccs()
{
  // ISSUE: Halftone detection
  // We should not remove tiny ccs if they are part of a halftone pattern...
  for (int i=0; i<ccs.size(); i++)
    {
      CC& cc = ccs[i];
      if (cc.npix <= tinysize)
        {
          // Mark cc to be erased
          Run *r = &runs[cc.frun];
          int nr = cc.nrun;
          cc.nrun = 0;
          cc.npix = 0;
          while (--nr >= 0)
            (r++)->ccid = -1;
        }
    }
}
 

// -- Merges small ccs and split large ccs
void
CCImage::merge_and_split_ccs()
{
  int ncc = ccs.size();
  int nruns = runs.size();
  int splitsize = largesize;
  if (ncc <= 0) return;
  // Grid of special components
  int gridwidth = (width+splitsize-1)/splitsize;
  int gridheight = (height+splitsize-1)/splitsize;
  int newncc = ncc+gridwidth*gridheight-1;
  int regcc = 0;
  // Set the correct ccids for the runs
  for (int ccid=0; ccid<ncc; ccid++)
    {
      CC* cc = &ccs[ccid];
      if (cc->nrun <= 0) continue;
      int ccheight = cc->bb.height();
      int ccwidth = cc->bb.width();
      if (ccheight<=smallsize && ccwidth<=smallsize)
        {
          int gridi = (cc->bb.ymin+cc->bb.ymax)/splitsize/2;
          int gridj = (cc->bb.xmin+cc->bb.xmax)/splitsize/2;
          int newccid = newncc + 1 - (gridi+1)*gridwidth + gridj;
          for(int runid=cc->frun; runid<cc->frun+cc->nrun; runid++)
            runs[runid].ccid = newccid;
        }
      else if (ccheight>=largesize || ccwidth>=largesize)
        {
          for(int runid=cc->frun; runid<cc->frun+cc->nrun; runid++)
            {
              Run& r = runs[runid];
              int y = r.y;
              int x_start = r.x1;
              int x_end = r.x2;
              int gridi = y/splitsize;
              int gridj_start = x_start/splitsize;
              int gridj_end = x_end/splitsize;
              int gridj_span = gridj_end-gridj_start;
              int newccid = newncc + 1 - (gridi+1)*gridwidth + gridj_start;
              if (! gridj_span)
                {
                  r.ccid = newccid;
                }
              else // gridj_span>0
                {
                  // truncate the current run 
                  r.ccid = newccid++;
                  int x = (gridj_start+1)*splitsize;
                  r.x2 = x-1;
                  runs.touch(nruns+gridj_span-1);
                  // append additional runs to the runs array
                  for(int gridj=gridj_start+1; gridj<gridj_end; gridj++)
                    {
                      Run& newrun = runs[nruns++];
                      newrun.y = y;
                      newrun.x1 = x;
                      x += splitsize;
                      newrun.x2 = x-1;
                      newrun.ccid = newccid++;
                    }
                  // append last run to the run array
                  Run& newrun = runs[nruns++];
                  newrun.y = y;
                  newrun.x1 = x;
                  newrun.x2 = x_end;
                  newrun.ccid = newccid++;                      
                }
            }
        }
      else
        {
          // This is a regular cc
          regcc += 1;
        }
    }
  // Recompute cc descriptors
  make_ccs_from_ccids();
  // Mark new ccs as special
  ncc = ccs.size();
  while(regcc < ncc)
    ccs[regcc++].special = true;
}


// -- Smooth non special ccs
void
CCImage::smooth_ccs()
{
  int nccs = ccs.size();
  for (int ccid=0; ccid<nccs; ccid++)
    {
      CC &cc = ccs[ccid];
      if (cc.special)
        continue;
      // Access runs
      int nrun = cc.nrun;
      Run *run = &runs[cc.frun];
      if (cc.bb.height() < 3)
        continue;
      // 1 - Smooth vertical edges
      {
        // Get three lines of runs
        int r0 = 0;
        int r1 = 0;
        int r2 = 0;
        // Loop on all three lines
        for (int y=cc.bb.ymin; y+2<cc.bb.ymax; y++)
          {
            while (r0<nrun && run[r0].y<y) r0++;
            while (r1<nrun && run[r1].y<y+1) r1++;
            while (r2<nrun && run[r2].y<y+2) r2++;
            // Loop on all runs on current line
            while (r0<nrun && run[r0].y == y)
              {
                // Synchronize left sides
                int x = run[r0].x1;
                while (r1<nrun && run[r1].y==y+1 && run[r1].x2<x-1) r1++;
                while (r2<nrun && run[r2].y==y+2 && run[r2].x2<x-1) r2++;
                // Align left sides
                if (run[r0].x1==run[r2].x1 && run[r1].x2!=run[r1].x1)
                  if (run[r1].y==y+1 && run[r2].y==y+2)
                    if (run[r1].x1==x-1 || run[r1].x1==x+1)
                      run[r1].x1 = x;
                // Synchronize right sides
                x = run[r0].x2;
                while (r1<nrun && run[r1].y==y+1 && run[r1].x2<x-1) r1++;
                while (r2<nrun && run[r2].y==y+2 && run[r2].x2<x-1) r2++;
                // Align right sides
                if (run[r0].x2==run[r2].x2 && run[r1].x2!=run[r1].x1)
                  if (run[r1].y==y+1 && run[r2].y==y+2)
                    if (run[r1].x2==x-1 || run[r1].x2==x+1)
                      run[r1].x2 = x;
                // Next run
                r0++;
              }
          }
      }
      // 2- Smooth horizontal edges
      {
        // Get three lines of runs
        int r0 = 0;
        int r1 = 0;
        int r2 = 0;
        // Loop on all three lines
        for (int y=cc.bb.ymin; y<cc.bb.ymax; y++)
          {
            while (r0<nrun && run[r0].y<y-1) r0++;
            while (r1<nrun && run[r1].y<y) r1++;
            while (r2<nrun && run[r2].y<y+1) r2++;
            // Loop on all runs on current line
            while (r1<nrun && run[r1].y == y)
              {
                // Lone black pixel
                if (run[r1].x1 == run[r1].x2)
                  {
                    int x = run[r1].x1;
                    while (r0<nrun && run[r0].y==y-1 && run[r0].x2<x-1) r0++;
                    while (r2<nrun && run[r2].y==y+1 && run[r2].x2<x-1) r2++;
                    if (run[r0].x1<=x-1 && run[r0].x2>=x+1 && run[r0].y==y-1)
                      if (run[r2].y!=y+1 || run[r2].x1>x+1 || run[r2].x2<x-1 )
                        { run[r1].ccid = -1; r1++; continue;  }
                    if (run[r2].x1<=x-1 && run[r2].x2>=x+1 && run[r2].y==y+1)
                      if (run[r0].y!=y-1 || run[r0].x1>x+1 || run[r0].x2<x-1 )
                        { run[r1].ccid = -1; r1++; continue; }
                  }
                // Next pixel
                r1++;
              }
          }
      }
    }
}


// -- Helps sorting cc
static int 
top_edges_descending (const void *pa, const void *pb)
{
  if (((CC*) pa)->bb.ymax != ((CC*) pb)->bb.ymax)
    return (((CC*) pb)->bb.ymax - ((CC*) pa)->bb.ymax);
  if (((CC*) pa)->bb.xmin != ((CC*) pb)->bb.xmin)
    return (((CC*) pa)->bb.xmin - ((CC*) pb)->bb.xmin);
  return (((CC*) pa)->frun - ((CC*) pb)->frun);
}


// -- Helps sorting cc
static int 
left_edges_ascending (const void *pa, const void *pb)
{
  if (((CC*) pa)->bb.xmin != ((CC*) pb)->bb.xmin)
    return (((CC*) pa)->bb.xmin - ((CC*) pb)->bb.xmin);
  if (((CC*) pb)->bb.ymax != ((CC*) pa)->bb.ymax)
    return (((CC*) pb)->bb.ymax - ((CC*) pa)->bb.ymax);
  return (((CC*) pa)->frun - ((CC*) pb)->frun);
}


// -- Helps sorting cc
static int 
integer_ascending (const void *pa, const void *pb)
{
  return ( *(int*)pb - *(int*)pa );
}


// -- Sort cc in approximate reading order
void 
CCImage::sort_in_reading_order()
{
  int nccs = ccs.size();
  if (nccs < 2) return;
  CC *ccarray = new CC[nccs];

  // Copy existing ccarray (but segregate special ccs)
  int ccid;
  int regularccpos = 0;
  int specialccpos = nccs-1;
  for(int i=0; i<nccs; i++)
    if(ccs[i].special)
      ccarray[specialccpos--] = ccs[i];
    else
      ccarray[regularccpos++] = ccs[i];

  // Sort the ccarray list into top-to-bottom order.
  qsort (ccarray, regularccpos, sizeof(CC), top_edges_descending);

  // Subdivide the ccarray list roughly into text lines [LYB]
  // - Determine maximal top deviation
  int maxtopchange = width / 40;
  if (maxtopchange < 32) 
    maxtopchange = 32;
  // - Loop until processing all ccs
  int ccno = 0;
  int *bottoms = new int[regularccpos];
  while (ccno < regularccpos)
    {
      // - Gather first line approximation
      int nccno;
      int sublist_top = ccarray[ccno].bb.ymax-1;
      int sublist_bottom = ccarray[ccno].bb.ymin;
      for (nccno=ccno; nccno < regularccpos; nccno++)
        {
          if (ccarray[nccno].bb.ymax-1 < sublist_bottom) break;
          if (ccarray[nccno].bb.ymax-1 < sublist_top - maxtopchange) break;
          int bottom = ccarray[nccno].bb.ymin;
          bottoms[nccno-ccno] = bottom;
          if (bottom < sublist_bottom)
            sublist_bottom = bottom;
        }
      // - If more than one candidate cc for the line
      if (nccno > ccno + 1)
        {
          // - Compute median bottom
          qsort(bottoms, nccno-ccno, sizeof(int), integer_ascending);
          int bottom = bottoms[ (nccno-ccno-1)/2 ];
          // - Compose final line
          for (nccno=ccno; nccno < regularccpos; nccno++)
            if (ccarray[nccno].bb.ymax-1 < bottom)
              break;
          // - Sort final line
          qsort (ccarray+ccno, nccno-ccno, sizeof(CC), left_edges_ascending);
        }
      // - Next line
      ccno = nccno;
    }

  // Copy ccarray back and renumber the runs
  for(ccid=0; ccid<nccs; ccid++)
    {
      CC& cc = ccarray[ccid];
      ccs[ccid] = cc;
      for(int r=cc.frun; r<cc.frun+cc.nrun; r++)
        runs[r].ccid = ccid;
    }

  // Free memory
  delete [] bottoms;
  delete[] ccarray;
}


// -- Creates a bitmap for a particular component
GP<GBitmap>   
CCImage::get_bitmap_for_cc(const int ccid) const
{
  const CC &cc = ccs[ccid];
  const GRect &bb = cc.bb;
  GP<GBitmap> bits = new GBitmap(bb.height(), bb.width());
  const Run *prun = & runs[(int)cc.frun];
  for (int i=0; i<cc.nrun; i++,prun++)
    {
      if (prun->y<bb.ymin || prun->y>=bb.ymax)
        THROW("Internal error (y bounds)");
      if (prun->x1<bb.xmin || prun->x2>=bb.xmax)
        THROW("Internal error (x bounds)");
      unsigned char *row = (*bits)[prun->y - bb.ymin];
      for (int x=prun->x1; x<=prun->x2; x++)
        row[x - bb.xmin] = 1;
    }
  return bits;
}


// -- Creates a JB2Image with the remaining components
GP<JB2Image> 
CCImage::get_jb2image() const
{
  if (ccs.hbound() < 0)
    THROW("Must first perform a cc analysis");
  GP<JB2Image> jimg = new JB2Image;
  jimg->set_dimension(width, height);
  if (runs.hbound() < 0)
    return jimg;
  // Iterate over CCs
  for (int ccid=0; ccid<=ccs.hbound(); ccid++)
    {
      JB2Shape shape;
      JB2Blit  blit;
      shape.parent = -1;
      shape.bits = get_bitmap_for_cc(ccid);
      shape.userdata = (ccs[ccid].special ? 1 : 0);
      blit.shapeno = jimg->add_shape(shape);
      blit.left = ccs[ccid].bb.xmin;
      blit.bottom = ccs[ccid].bb.ymin;
      jimg->add_blit(blit);
      shape.bits->compress();
    }
  // Return
  return jimg;
}











// --------------------------------------------------
// PATTERN MATCHING
// --------------------------------------------------



// -- Candidate descriptor for pattern matching
struct MatchData 
{
  GBitmap *bits;       // bitmap pointer
  int area;            // number of black pixels
};


// -- Creates shape hierarchy and substitutions
void
tune_jb2image(JB2Image *jimg, 
              int substitute_threshold=0,  // max percent of different pixels in order to substitute
              int refine_threshold=21      // max percent of different pixels in order to cross-code
              )
{
  // ISSUES: pattern matching
  // Better criterions for substitution lead to faster code and improved compression ratios.
  // Beware of character substitution errors!
  
  // Pattern matching data
  int nshapes = jimg->get_shape_count();
  GTArray<MatchData> library(nshapes);
  MatchData *lib = library;    // for faster access  
  
  // Loop on all shapes
  for (int current=0; current<nshapes; current++)
    {
      lib[current].bits = 0;
      // Skip ``special shapes''
      JB2Shape *jshp = jimg->get_shape(current);
      if (jshp->userdata || ! jshp->bits) 
        continue; 
      // Compute matchdata info
      GBitmap *bitmap = jshp->bits;
      int row;
      int rows = bitmap->rows();
      int column;
      int columns = bitmap->columns();
      int black_pixels = 0;
      for (row = rows - 1; row >= 0; row--) 
        for (column = 0; column < columns; column++) 
          if ((*bitmap)[row][column]) 
            black_pixels++;
      lib[current].bits = bitmap;
      lib[current].area = black_pixels;

      // Prepare for search
      int closest_match = -1;
      int best_score = (refine_threshold * rows * columns + 50) / 100;
      if (best_score < 2) best_score = 2;
      bitmap->minborder(2); // ensure sufficient borders
      
      // Search closest match
      for (int candidate = 0; candidate < current; candidate++) 
        {
          // Access candidate bitmap
          GBitmap *cross_bitmap = lib[candidate].bits;
          if (! cross_bitmap) continue;
          int cross_columns = cross_bitmap->columns();
          int cross_rows = cross_bitmap->rows();
          // Prune
          if (abs (lib[candidate].area - black_pixels) > best_score) continue;
          if (abs (cross_rows - rows) > 2) continue;
          if (abs (cross_columns - columns) > 2) continue;
          // Compute alignment
          int cross_column_adjust = (cross_columns  - cross_columns/2) - (columns - columns/2);
          int cross_row_adjust = (cross_rows  - cross_rows/2) - (rows - rows/2);
          // Ensure adequate borders
          cross_bitmap->minborder (1-cross_column_adjust);
          cross_bitmap->minborder (1+columns-cross_columns+cross_column_adjust);
          // Count pixel differences
          int score = 0;
          unsigned char *p_row;
          unsigned char *p_cross_row;
          for (row = 0; row < rows; row++) 
            {
              p_row = (*bitmap) [row];
              p_cross_row  = (*cross_bitmap)[row+cross_row_adjust] + cross_column_adjust;
              for (column = 0; column < columns; column++) 
                if (p_row [column] != p_cross_row [column])
                  score ++;
              if (score >= best_score)  // prune
                break;
            }
          if (score < best_score) {
            best_score = score;
            closest_match = candidate;
          }
        }
      // Setup hierarchy
      if (closest_match >= 0)
        {
          // This shape will be cross-coded
          jshp->parent = closest_match;
          // Substitutions are marked by setting jshp->bits to zero
          if ((best_score * 100) <= (substitute_threshold * rows * columns + 50))
            lib[current].bits = jshp->bits = 0;
        }
    }
  
  // Process shape substitutions
  for (int blitno=0; blitno<jimg->get_blit_count(); blitno++)
    {
      JB2Blit *jblt = jimg->get_blit(blitno);
      JB2Shape *jshp = jimg->get_shape(jblt->shapeno);
      if (jshp->bits==0 && jshp->parent>=0)
        jblt->shapeno = jshp->parent; // blit directly accesses substitute
    }
}









// --------------------------------------------------
// COMPLETE COMPRESSION ROUTINE
// --------------------------------------------------

struct cjb2opts {
  int dpi;
  int substitute_threshold;
  bool smooth;
  bool clean; 
};


void 
cjb2(const char *filein, const char *fileout, const cjb2opts &opts)
{
  StdioByteStream ibs(filein, "rb");
  GBitmap input(ibs);

  // Read input image
  CCImage rimg(input.columns(), input.rows(), opts.dpi);  // construct CCImage
  rimg.add_bitmap_runs(input);       // fill CCImage
  input.init(0,0);                   // save memory

  // Component analysis
  rimg.make_ccids_by_analysis();             // obtain ccids
  rimg.make_ccs_from_ccids();                // compute cc descriptors
  if (opts.clean) 
    rimg.erase_tiny_ccs();                   // clean
  rimg.merge_and_split_ccs();                // reorganize weird ccs
  if (opts.smooth) 
    rimg.smooth_ccs();                       // smooth
  rimg.sort_in_reading_order();              // sort cc descriptors
  
  // Pattern matching
  GP<JB2Image> jimg = rimg.get_jb2image();          // get ``raw'' jb2image
  rimg.runs.empty();                                // save memory
  rimg.ccs.empty();                                 // save memory
  tune_jb2image(jimg, opts.substitute_threshold);   // organize jb2image

  // Code
  StdioByteStream obs(fileout, "wb");
  IFFByteStream iff(obs);
  // -- main composite chunk
  iff.put_chunk("FORM:DJVU");
  // -- ``INFO'' chunk
  DjVuInfo info;
  info.height = rimg.height;
  info.width = rimg.width;
  info.dpi = opts.dpi;
  iff.put_chunk("INFO");
  info.encode(iff);
  iff.close_chunk();
  // -- ``Sjbz'' chunk
  iff.put_chunk("Sjbz");
  jimg->encode(iff);
  iff.close_chunk();
  // -- terminate main composite chunk
  iff.close_chunk();

  // Finished!
}
      





// --------------------------------------------------
// MAIN
// --------------------------------------------------


#if IMPLEMENT_MAIN

void
usage()
{
  fprintf(stderr,"Usage: cjb2 [options] <inputpbmfile> <outputdjvufile>\n"
          "Options are:\n"
          "   -dpi xxx     Specify image resolution (default 300).\n"
          "   -smooth      Smooth characters shapes (lossy).\n"
          "   -clean       Remove small flyspecs (lossy).\n"
          "   -loose       Substitute patterns with small variations (lossy).\n"
          "Encoding is lossless unless one or several lossy options are selected.\n" );
  exit(10);
}


int 
main(int argc, const char **argv)
{
  TRY
    {
      GString inputpbmfile;
      GString outputdjvufile;
      cjb2opts opts;
      // Defaults
      opts.dpi = 300;
      opts.substitute_threshold = 0;
      opts.clean = false;
      opts.smooth = false;
      // Parse options
      for (int i=1; i<argc; i++)
        {
          GString arg = argv[i];
          if (arg == "-dpi" && i+1<argc)
            {
              char *end;
              opts.dpi = strtol(argv[++i], &end, 10);
              if (*end || opts.dpi<75 || opts.dpi>144000)
                usage();
            }
          else if (arg == "-clean")
            opts.clean = true;
          else if (arg == "-smooth")
            opts.smooth = true;
          else if (arg == "-loose")
            opts.substitute_threshold = 5;
          else if (arg[0] == '-')
            usage();
          else if (!inputpbmfile)
            inputpbmfile = arg;
          else if (!outputdjvufile)
            outputdjvufile = arg;
          else
            usage();
        }
      if (!inputpbmfile || !outputdjvufile)
        usage();
      // Execute
      cjb2(inputpbmfile, outputdjvufile, opts);
    }
  CATCH(ex)
    {
      ex.perror();
      exit(1);
    }
  ENDCATCH;
  return 0;
}


#endif
