//C-  -*- C++ -*-
//C- DjVu® Reference Library (v. 3.5)
//C- 
//C- Copyright © 1999-2001 LizardTech, Inc. All Rights Reserved.
//C- The DjVu Reference Library is protected by U.S. Pat. No.
//C- 6,058,214 and patents pending.
//C- 
//C- This software is subject to, and may be distributed under, the
//C- GNU General Public License, Version 2. The license should have
//C- accompanied the software or you may obtain a copy of the license
//C- from the Free Software Foundation at http://www.fsf.org .
//C- 
//C- The computer code originally released by LizardTech under this
//C- license and unmodified by other parties is deemed the "LizardTech
//C- Original Code."
//C- 
//C- With respect to the LizardTech Original Code ONLY, and subject
//C- to any third party intellectual property claims, LizardTech
//C- grants recipient a worldwide, royalty-free, non-exclusive license
//C- under patent claims now or hereafter owned or controlled by
//C- LizardTech that are infringed by making, using, or selling
//C- LizardTech Original Code, but solely to the extent that any such
//C- patent(s) is/are reasonably necessary to enable you to make, have
//C- made, practice, sell, or otherwise dispose of LizardTech Original
//C- Code (or portions thereof) and not to any greater extent that may
//C- be necessary to utilize further modifications or combinations.
//C- 
//C- The LizardTech Original Code is provided "AS IS" WITHOUT WARRANTY
//C- OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
//C- TO ANY WARRANTY OF NON-INFRINGEMENT, OR ANY IMPLIED WARRANTY OF
//C- MERCHANTIBILITY OR FITNESS FOR A PARTICULAR PURPOSE.
// 
// $Id: d44.cpp,v 1.26 2001-09-26 18:29:45 leonb Exp $
// $Name:  $

/** @name d44

    {\bf Synopsis}\\
    \begin{verbatim}
        d44 [-verbose] [-chunks n] iw44file [pnmfile]
    \end{verbatim}

    {\bf Description} ---
    File #"d44.cpp"# illustrates the use of classes \Ref{IWBitmap} and
    \Ref{IWPixmap} for decompressing a color image or a gray level 
    encoded using DjVu IW44 wavelets.  Such files are typically created
    using program \Ref{c44}. 

    {\bf Arguments} --- Argument #iw4file# is the name of the input file
    containing IW44 encoded data.  These files usually have suffix #".djvu"#,
    #".djv"#, #".iw44"# or #".iw4"#.  The output file will be a PPM file for a
    color image or a PGM file for a gray level image.  These formats can be
    converted into other file formats using the NetPBM package
    (\URL{http://www.arc.umn.edu/GVL/Software/netpbm.html}) or the ImageMagick
    package (\URL{http://www.wizards.dupont.com/cristy}).  Argument #pnmfile#
    is the name of the output file.  A single dash #"-"# can be used to
    represent the standard output.  If this argument is omitted, a filename is
    generated by replacing the suffix of #iw4file# with suffix #".pgm"# or
    #".ppm"#.

    {\bf Options} ---
    The following options are recognized.
    \begin{description}
    \item[-chunks n]
    Decodes only the first #n# chunks of the file.
    This option allows you to render the successive images displayed
    while downloading this IW44 file into a web browser.
    \item[-verbose]
    Prints a message describing the decompression times and the memory
    requirements.  Decompression is a two stage process. The IW44 data is
    first decoded and the wavelet coefficients are stored into a memory
    efficient data structure. This data structure is then used to render the
    final image.  
    \begin{verbatim}
    % d44 -v lag.djvu - | xv -
    image: color 510 x 684
    times: 421ms (decoding) + 340ms (rendering)
    memory: 678kB (24% active coefficients)
    \end{verbatim}
    \end{description}

    @memo
    DjVu IW44 wavelet decoder.
    @author
    L\'eon Bottou <leonb@research.att.com>
    @version
    #$Id: d44.cpp,v 1.26 2001-09-26 18:29:45 leonb Exp $# 
*/
//@{
//@}

#include "DjVuGlobal.h"
#include "GString.h"
#include "GException.h"
#include "IW44Image.h"
#include "GOS.h"
#include "GURL.h"
#include "IFFByteStream.h"
#include "GPixmap.h"
#include "GBitmap.h"
#include "DjVuMessage.h"
#include <locale.h>
#include <stdlib.h>
#ifdef UNDER_CE
#include <windows.h>
#endif

// global data

int flag_verbose = 0;
int flag_chunks = 9999;
int flag_addsuffix = 0;
GURL pnmurl;
GURL iw4url;



// parse arguments

void 
usage()
{
  printf("D44 -- Image decompression utility using Interpolating Wavelets (4,4)\n"
         "  Copyright Â© 1999-2000 LizardTech, Inc. All Rights Reserved.\n"
         "Usage: d44 [options] iw4file [pnmfile]\n"
         "Options:\n"
         "    -verbose     -- report decoding time and memory use\n"
         "    -chunks n    -- select number of chunks to decode\n"
         "\n");
  exit(1);
}


void
parse(GArray<GUTF8String> &argv)
{
  const int argc=argv.hbound()+1;
  for (int i=1; i<argc; i++)
    {
      if (argv[i][0] == '-' && argv[i][1])
        {
          if (argv[i][1] == 'v')
            {
              flag_verbose = 1;
            }
          else if (argv[i][1] == 'c')
            {
              if (++i >= argc)
                G_THROW("d44: missing argument after option -chunks");
              char *ptr;
              flag_chunks = strtol(argv[i], &ptr, 10);
              if (*ptr || flag_chunks<=0 || flag_chunks>999)
                G_THROW("d44: illegal argument after option -chunks");
            }
          else
            usage();
        }
      else if (iw4url.is_empty())
        iw4url = GURL::Filename::UTF8(argv[i]);
      else if (pnmurl.is_empty())
        pnmurl = GURL::Filename::UTF8(argv[i]);
      else
        usage();
    }
  if (iw4url.is_empty())
    usage();
  if (pnmurl.is_empty())
    {
      const GURL codebase = iw4url.base();
      GUTF8String base = iw4url.fname();
      int dot = base.rsearch('.');
      if (dot >= 1)
        base = base.substr(0,dot);
      pnmurl = GURL::UTF8(base,codebase);
      flag_addsuffix = 1;
    }
}


int 
#ifndef UNDER_CE
main(int argc, char **argv)
#else
mymain(int argc, char **argv)
#endif
{
  setlocale(LC_ALL,"");
  djvu_programname(argv[0]);
  GArray<GUTF8String> dargv(0,argc-1);
  for(int i=0;i<argc;++i)
    dargv[i]=GNativeString(argv[i]);
  G_TRY
    {
      // Parse arguments
      parse(dargv);
      // Check input file
      GP<ByteStream> gibs=ByteStream::create(iw4url,"rb");
      ByteStream &ibs=*gibs;
      GUTF8String chkid;
      // Determine file type
      { 
        GP<IFFByteStream> giff=IFFByteStream::create(gibs);
        IFFByteStream &iff=*giff;
        if (! iff.get_chunk(chkid))
          G_THROW("d44: malformed IW4 file");
        ibs.seek(0);
      }
      // Go decoding
      if (chkid == "FORM:DJVM")
	      G_THROW("This is multipage DJVU file. Please break it into pieces.");
      const bool color=("FORM:PM44" == chkid)?true:false;
      if (!color && !("FORM:BM44" == chkid))
      {
        G_THROW("d44: expected BM44 or PM44 chunk in IW4 file");
      }
      GP<IFFByteStream> giff=IFFByteStream::create(gibs);
      IFFByteStream &iff=*giff;
      GP<IW44Image> iw=IW44Image::create_decode((IW44Image::ImageType)color);
      const int stime = GOS::ticks();
      iw->decode_iff(iff, flag_chunks);
      const int dtime = GOS::ticks() - stime;
      GP<GPixmap> ppm;
      GP<GBitmap> pgm;
      if(color)
      {
        ppm = iw->get_pixmap();
      }else
      {
        pgm = iw->get_bitmap();
      }
      const int rtime = GOS::ticks() - stime - dtime;
      if (flag_verbose)
      {
        GUTF8String kind = DjVuMessage::LookUpUTF8( color ? ERR_MSG("color.color") : ERR_MSG("color.gray") );
        DjVuFormatErrorUTF8( "%s\t%s\t%d\t%d\t%d\t%d\t%d\t%d", 
                         ERR_MSG("d44.summary"),
                         (const char *)kind,
                         iw->get_width(), iw->get_height(), dtime, rtime, 
                         (iw->get_memory_usage()+512)/1024, iw->get_percent_memory());
      }
      if (flag_addsuffix)
        pnmurl=GURL::UTF8(pnmurl.name()+(color?".ppm":".pgm"),pnmurl.base());
#ifndef UNDER_CE
      pnmurl.deletefile();
#else
      WCHAR tszPnmFile[MAX_PATH] ;
      MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,pnmurl.UTF8Filename(),pnmurl.UTF8Filename().length()+1,tszPnmFile,sizeof(tszPnmFile)) ;
      DeleteFile(tszPnmFile) ;
#endif
      GP<ByteStream> obs=ByteStream::create(pnmurl,"wb");
      if(color)
      {
        ppm->save_ppm(*obs);
      }else
      {
        pgm->save_pgm(*obs);
      }
    }
  G_CATCH(ex)
    {
      ex.perror();
      exit(1);
    }
  G_ENDCATCH;
  return 0;
}

#ifdef UNDER_CE

int WINAPI WinMain (HINSTANCE hInstance,
		             HINSTANCE hPrevInstance,
                     LPTSTR lpCmdLine,
                     int nCmdShow)
{
   char *argv[3] ;
   argv[0]="-" ;
   argv[1]="-verbose" ;
   argv[2]="enigmaphoto.djvu" ;
   mymain (3, argv) ;
   return (0) ;
}
#endif
