<HTML>
<HEAD>
   <TITLE>class  ByteStream</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.1">
</HEAD>
<BODY BGCOLOR=#fefefe BACKGROUND=back.jpg>

<H2>class  <A HREF="#DOC.DOCU">ByteStream</A>: public <!1><A HREF="GPEnabled.html#DOC.1.4.4.1.2">GPEnabled</A></H2>
<BLOCKQUOTE>Abstract class for a stream of bytes.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=215>
<param name=classes value="CGPEnabled,MGPEnabled.html,CByteStream,MByteStream.html,CIFFByteStream,MIFFByteStream.html,CStdioByteStream,MStdioByteStream.html,CStaticByteStream,MStaticByteStream.html,CMemoryByteStream,MMemoryByteStream.html,CBSByteStream,MBSByteStream.html">
<param name=before value="M,M,M|_,MR_,MR_,MR_,Mr_">
<param name=after value="Md_,M,M,M,M,M,M">
<param name=indent value="0,1,1,1,1,1,1">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public</H3><DD><DT>
<A HREF="#DOC.1.4.12.1.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Virtual Functions.</B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.4.12.1.1.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   <B>~ByteStream</B>()
<DD><I>Virtual destructor.</I>
<DT>
<A HREF="#DOC.1.4.12.1.1.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   size_t <B>read</B>(void *buffer, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>)
<DD><I>Reads data from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.1.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   size_t <B>write</B>(const void *buffer, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>)
<DD><I>Writes data to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.1.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   long <B>tell</B>(void) const 
<DD><I>Returns the offset of the current position in the ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.1.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   int <B>seek</B>(long offset, int whence = SEEK_SET, bool nothrow=false)
<DD><I>Sets the current position for reading or writing the ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.1.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>flush</B>(void)
<DD><I>Flushes all buffers in the ByteStream.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.4.12.1.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Utility Functions.  </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.4.12.1.2.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>size_t <B>readall</B>(void *buffer, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>)
<DD><I>Reads data and blocks until everything has been read.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>size_t <B>writall</B>(const void *buffer, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>)
<DD><I>Writes data and blocks until everything has been written.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>size_t <B>copy</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bsfrom, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>=0)
<DD><I>Copy data from another ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write8</B>(unsigned int card8)
<DD><I>Writes a one-byte integer to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write16</B>(unsigned int card16)
<DD><I>Writes a two-bytes integer to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write24</B>(unsigned int card24)
<DD><I>Writes a three-bytes integer to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.7"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write32</B>(unsigned int card32)
<DD><I>Writes a four-bytes integer to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.8"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>read8</B>()
<DD><I>Reads a one-byte integer from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.9"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>read16</B>()
<DD><I>Reads a two-bytes integer from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.10"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>read24</B>()
<DD><I>Reads a three-bytes integer from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.11"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>read32</B>()
<DD><I>Reads a four-bytes integer from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.4.12.1.2.12"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   int <B>size</B>(void) const 
<DD><I>Returns the total number of bytes contained in the buffer, file, etc.</I>
</DL></P>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="GPEnabled.html">GPEnabled</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="GPEnabled.html#DOC.1.4.4.1.2">GPEnabled</A>&amp; <B>operator=</B>(const <!1><A HREF="GPEnabled.html#DOC.1.4.4.1.2">GPEnabled</A> &amp; obj)
<DT>
<IMG ALT="o" SRC=icon2.gif>int <B>get_count</B>(void) const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>volatile   int <B>count</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU">
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>Abstract class for a stream of bytes.  Class <TT>ByteStream</TT> represent an
object from which (resp. to which) bytes can be read (resp. written) as
with a regular file.  Virtual functions <TT>read</TT> and <TT>write</TT> must implement
these two basic operations.  In addition, function <TT>tell</TT> returns an
offset identifying the current position, and function <TT>seek</TT> may be used
to change the current position.<P><B>Note</B>. Both the copy constructor and the copy operator are declared
as private members. It is therefore not possible to make multiple copies
of instances of this class, as implied by the class semantic.  </BLOCKQUOTE>
<DL>

<A NAME="Virtual Functions.">
<A NAME="DOC.1.4.12.1.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Virtual Functions.</B></TT>
<DD>These functions are usually implemented by each subclass of <TT>ByteStream</TT>. 
<DL><DT><DD></DL><P><DL>

<A NAME="~ByteStream">
<A NAME="DOC.1.4.12.1.1.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   ~ByteStream()</B></TT>
<DD>Virtual destructor. 
<DL><DT><DD></DL><P>
<A NAME="read">
<A NAME="DOC.1.4.12.1.1.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   size_t read(void *buffer, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>)</B></TT>
<DD>Reads data from a ByteStream.  This function <EM>must</EM> be implemented
by each subclass of <TT>ByteStream</TT>.  At most <TT>size</TT> bytes are read from
the ByteStream and stored in the memory area pointed to by <TT>buffer</TT>.
Function <TT>read</TT> returns immediately if <TT>size</TT> is zero. The actual number
of bytes read is returned.  Function <TT>read</TT> returns a number of bytes
smaller than <TT>size</TT> if the end-of-file mark is reached before filling
the buffer. Subsequent invocations will always return value <TT>0</TT>.
Function <TT>read</TT> may also return a value greater than zero but smaller
than <TT>size</TT> for internal reasons. Programs must be ready to handle these
cases or use function <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.1">readall</A>. Exception <!1><A HREF="GException.html">GException</A> is
thrown with a plain text error message whenever an error occurs. 
<DL><DT><DD></DL><P>
<A NAME="write">
<A NAME="DOC.1.4.12.1.1.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   size_t write(const void *buffer, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>)</B></TT>
<DD>Writes data to a ByteStream.  This function <EM>must</EM> be implemented by
each subclass of <TT>ByteStream</TT>.  At most <TT>size</TT> bytes from buffer
<TT>buffer</TT> are written to the ByteStream.  Function <TT>write</TT> returns
immediately if <TT>size</TT> is zero.  The actual number of bytes written is
returned. Function <TT>write</TT> may also return a value greater than zero but
smaller than <TT>size</TT> for internal reasons. Programs must be ready to
handle these cases or use function <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.2">writall</A>. Exception
<!1><A HREF="GException.html">GException</A> is thrown with a plain text error message whenever an
error occurs. 
<DL><DT><DD></DL><P>
<A NAME="tell">
<A NAME="DOC.1.4.12.1.1.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   long tell(void) const </B></TT>
<DD>Returns the offset of the current position in the ByteStream.  This
function <EM>must</EM> be implemented by each subclass of <TT>ByteStream</TT>. 
<DL><DT><DD></DL><P>
<A NAME="seek">
<A NAME="DOC.1.4.12.1.1.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   int seek(long offset, int whence = SEEK_SET, bool nothrow=false)</B></TT>
<DD>Sets the current position for reading or writing the ByteStream.  Class
<TT>ByteStream</TT> provides a default implementation able to seek forward by
calling function <TT>read</TT> until reaching the desired position.  Subclasses
implementing better seek capabilities must override this default
implementation.  The new current position is computed by applying
displacement <TT>offset</TT> to the position represented by argument
<TT>whence</TT>. The following values are recognized for argument <TT>whence</TT>:
<DL>
<DT><B><TT>SEEK_SET</TT></B><DD> Argument <TT>offset</TT> indicates the position relative to
the beginning of the ByteStream.
<DT><B><TT>SEEK_CUR</TT></B><DD> Argument <TT>offset</TT> is a signed displacement relative to
the current position.
<DT><B><TT>SEEK_END</TT></B><DD> Argument <TT>offset</TT> is a displacement relative to the end
of the file. It is then advisable to provide a negative value for <TT>offset</TT>.
</DL>
Results are undefined whenever the new position is greater than the
total size of the ByteStream.<P><B>Error reporting</B>:
If <TT>seek()</TT> succeeds, <TT>0</TT> is returned. Otherwise it either returns
<TT>-1</TT> (if <TT>nothrow</TT> is set to <TT>FALSE</TT>) or throws the <!1><A HREF="GException.html">GException</A>
exception. 
<DL><DT><DD></DL><P>
<A NAME="flush">
<A NAME="DOC.1.4.12.1.1.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void flush(void)</B></TT>
<DD>Flushes all buffers in the ByteStream.  Calling this function
guarantees that pending data have been actually written (i.e. passed to
the operating system). Class <TT>ByteStream</TT> provides a default
implementation which does nothing. 
<DL><DT><DD></DL><P></DL>

<A NAME="Utility Functions.  ">
<A NAME="DOC.1.4.12.1.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Utility Functions.  </B></TT>
<DD>Class <TT>ByteStream</TT> implements these functions using the virtual
interface functions only.  All subclasses of <TT>ByteStream</TT> inherit these
functions. 
<DL><DT><DD></DL><P><DL>

<A NAME="readall">
<A NAME="DOC.1.4.12.1.2.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>size_t readall(void *buffer, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>)</B></TT>
<DD>Reads data and blocks until everything has been read.  This function is
essentially similar to function <TT>read</TT>.  Unlike function <TT>read</TT> however,
function <TT>readall</TT> will never return a value smaller than <TT>size</TT> unless
an end-of-file mark is reached.  This is implemented by repeatedly
calling function <TT>read</TT> until everything is read or until we reach an
end-of-file mark.  Note that <TT>read</TT> and <TT>readall</TT> are equivalent when
<TT>size</TT> is one. 
<DL><DT><DD></DL><P>
<A NAME="writall">
<A NAME="DOC.1.4.12.1.2.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>size_t writall(const void *buffer, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>)</B></TT>
<DD>Writes data and blocks until everything has been written.  This function
is essentially similar to function <TT>write</TT>.  Unlike function <TT>write</TT>
however, function <TT>writall</TT> will only return after all <TT>size</TT> bytes have
been written.  This is implemented by repeatedly calling function
<TT>write</TT> until everything is written.  Note that <TT>write</TT> and <TT>writall</TT>
are equivalent when <TT>size</TT> is one. 
<DL><DT><DD></DL><P>
<A NAME="copy">
<A NAME="DOC.1.4.12.1.2.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>size_t copy(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bsfrom, size_t <!1><A HREF="ByteStream.html#DOC.1.4.12.1.2.12">size</A>=0)</B></TT>
<DD>Copy data from another ByteStream.  A maximum of <TT>size</TT> bytes are read
from the ByteStream <TT>bsfrom</TT> and are written to the ByteStream <TT>*this</TT>
at the current position.  Less than <TT>size</TT> bytes may be written if an
end-of-file mark is reached on <TT>bsfrom</TT>.  This function returns the
total number of bytes copied.  Setting argument <TT>size</TT> to zero (the
default value) has a special meaning: the copying process will continue
until reaching the end-of-file mark on ByteStream <TT>bsfrom</TT>, regardless
of the number of bytes transferred.  
<DL><DT><DD></DL><P>
<A NAME="write8">
<A NAME="DOC.1.4.12.1.2.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void write8(unsigned int card8)</B></TT>
<DD>Writes a one-byte integer to a ByteStream. 
<DL><DT><DD></DL><P>
<A NAME="write16">
<A NAME="DOC.1.4.12.1.2.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void write16(unsigned int card16)</B></TT>
<DD>Writes a two-bytes integer to a ByteStream.
The integer most significant byte is written first,
regardless of the processor endianness. 
<DL><DT><DD></DL><P>
<A NAME="write24">
<A NAME="DOC.1.4.12.1.2.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void write24(unsigned int card24)</B></TT>
<DD>Writes a three-bytes integer to a ByteStream.
The integer most significant byte is written first,
regardless of the processor endianness. 
<DL><DT><DD></DL><P>
<A NAME="write32">
<A NAME="DOC.1.4.12.1.2.7">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void write32(unsigned int card32)</B></TT>
<DD>Writes a four-bytes integer to a ByteStream. 
The integer most significant bytes are written first,
regardless of the processor endianness. 
<DL><DT><DD></DL><P>
<A NAME="read8">
<A NAME="DOC.1.4.12.1.2.8">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int read8()</B></TT>
<DD>Reads a one-byte integer from a ByteStream. 
<DL><DT><DD></DL><P>
<A NAME="read16">
<A NAME="DOC.1.4.12.1.2.9">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int read16()</B></TT>
<DD>Reads a two-bytes integer from a ByteStream.
The integer most significant byte is read first,
regardless of the processor endianness. 
<DL><DT><DD></DL><P>
<A NAME="read24">
<A NAME="DOC.1.4.12.1.2.10">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int read24()</B></TT>
<DD>Reads a three-bytes integer from a ByteStream.
The integer most significant byte is read first,
regardless of the processor endianness. 
<DL><DT><DD></DL><P>
<A NAME="read32">
<A NAME="DOC.1.4.12.1.2.11">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int read32()</B></TT>
<DD>Reads a four-bytes integer from a ByteStream.
The integer most significant bytes are read first,
regardless of the processor endianness. 
<DL><DT><DD></DL><P>
<A NAME="size">
<A NAME="DOC.1.4.12.1.2.12">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   int size(void) const </B></TT>
<DD>Returns the total number of bytes contained in the buffer, file, etc.
Valid offsets for function <TT>seek</TT> range from 0 to the value returned
by this function. 
<DL><DT><DD></DL><P></DL>
</DL>
<HR>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="IFFByteStream.html">IFFByteStream</A><BR>
<A HREF="StdioByteStream.html">StdioByteStream</A><BR>
<A HREF="StaticByteStream.html">StaticByteStream</A><BR>
<A HREF="MemoryByteStream.html">MemoryByteStream</A><BR>
<A HREF="BSByteStream.html">BSByteStream</A><BR>
</DL>

<DL><DT><DD></DL><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I><P><HR>
<!-- This is were the DOC++ footer is defined  -->

<font face="arial,helvetica" size="2">
<a href=http://www.lizardtech.com>DjVu</a> is a trademark of LizardTech, Inc.  
<br>All other products mentioned are registered trademarks or trademarks of
their respective companies.
</font>
