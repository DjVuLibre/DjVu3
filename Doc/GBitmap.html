<HTML>
<HEAD>
   <TITLE>class  GMonitor::GBitmap</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.1">
</HEAD>
<BODY BGCOLOR=#fefefe BACKGROUND=back.jpg>

<H2>class  <A HREF="#DOC.DOCU">GBitmap</A>: public <!1><A HREF="GPEnabled.html#DOC.1.5.4.1.2">GPEnabled</A></H2>
<BLOCKQUOTE>Bilevel and gray-level images.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CGPEnabled,MGPEnabled.html,CGBitmap,MGBitmap.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public</H3><DD><DT>
<A HREF="#DOC.1.5.17.1.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Construction. </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.1.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>GBitmap</B>()
<DD><I>Constructs an empty GBitmap object.</I>
<DT>
<A HREF="#DOC.1.5.17.1.1.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>GBitmap</B>(int nrows, int ncolumns, int border=0)
<DD><I>Constructs a GBitmap with <TT>nrows</TT> rows and <TT>ncolumns</TT> columns.</I>
<DT>
<A HREF="#DOC.1.5.17.1.1.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>GBitmap</B>(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref)
<DD><I>Copy constructor.</I>
<DT>
<A HREF="#DOC.1.5.17.1.1.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>GBitmap</B>(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref, int border)
<DD><I>Constructs a GBitmap by copying the contents of GBitmap <TT>ref</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.1.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>GBitmap</B>(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref, const <!1><A HREF="GRect.html">GRect</A> &amp;rect, int border=0)
<DD><I>Constructs a GBitmap by copying a rectangular segment <TT>rect</TT> of GBitmap <TT>ref</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.1.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>GBitmap</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;ref, int border=0)
<DD><I>Constructs a GBitmap by reading PBM, PGM or RLE data from ByteStream <TT>ref</TT> into this GBitmap.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.5.17.1.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Initialization. </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.2.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>init</B>(int nrows, int ncolumns, int border=0)
<DD><I>Resets this GBitmap size to <TT>nrows</TT> rows and <TT>ncolumns</TT> columns and sets all pixels to white.</I>
<DT>
<A HREF="#DOC.1.5.17.1.2.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>init</B>(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref, int border=0)
<DD><I>Initializes this GBitmap with the contents of the GBitmap <TT>ref</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.2.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>init</B>(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref, const <!1><A HREF="GRect.html">GRect</A> &amp;rect, int border=0)
<DD><I>Initializes this GBitmap with a rectangular segment <TT>rect</TT> of GBitmap <TT>ref</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.2.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>init</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;ref, int border=0)
<DD><I>Reads PBM, PGM or RLE data from ByteStream <TT>ref</TT> into this GBitmap.</I>
<DT>
<A HREF="#DOC.1.5.17.1.2.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A>&amp; <B>operator=</B>(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref)
<DD><I>Assignment operator.</I>
<DT>
<A HREF="#DOC.1.5.17.1.2.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>fill</B>(unsigned char value)
<DD><I>Initializes all the GBitmap pixels to value <TT>value</TT>.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.5.17.1.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Accessing the pixels. </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.3.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>rows</B>() const 
<DD><I>Returns the number of rows (the image height).</I>
<DT>
<A HREF="#DOC.1.5.17.1.3.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>columns</B>() const 
<DD><I>Returns the number of columns (the image width).</I>
<DT>
<A HREF="#DOC.1.5.17.1.3.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>const unsigned char* <B>operator[] </B>(int row) const 
<DD><I>Returns a constant pointer to the first byte of row <TT>row</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.3.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned char* <B>operator[] </B>(int row)
<DD><I>Returns a pointer to the first byte of row <TT>row</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.3.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>rowsize</B>() const 
<DD><I>Returns the size of a row in memory (in pixels).</I>
<DT>
<A HREF="#DOC.1.5.17.1.3.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>minborder</B>(int minimum)
<DD><I>Makes sure that the border is at least <TT>minimum</TT> pixels large.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.5.17.1.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Managing gray levels. </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.4.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>get_grays</B>() const 
<DD><I>Returns the number of gray levels.</I>
<DT>
<A HREF="#DOC.1.5.17.1.4.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>set_grays</B>(int grays)
<DD><I>Sets the number of gray levels without changing the pixels.</I>
<DT>
<A HREF="#DOC.1.5.17.1.4.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>change_grays</B>(int grays)
<DD><I>Changes the number of gray levels.</I>
<DT>
<A HREF="#DOC.1.5.17.1.4.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>binarize_grays</B>(int threshold=0)
<DD><I>Binarizes a gray level image using a threshold.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.5.17.1.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Optimizing the memory usage.  </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.5.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>compress</B>()
<DD><I>Reduces the memory required for a bilevel image by using a run-length encoded representation.</I>
<DT>
<A HREF="#DOC.1.5.17.1.5.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>uncompress</B>()
<DD><I>Decodes run-length encoded bitmaps and recreate the pixel array.</I>
<DT>
<A HREF="#DOC.1.5.17.1.5.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>get_memory_usage</B>() const 
<DD><I>Returns the number of bytes allocated for this image.</I>
<DT>
<A HREF="#DOC.1.5.17.1.5.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GMonitor.html">GMonitor</A>* <B>monitor</B>() const 
<DD><I>Returns a possibly null pointer to a <!1><A HREF="GMonitor.html">GMonitor</A> for this bitmap.</I>
<DT>
<A HREF="#DOC.1.5.17.1.5.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>share</B>()
<DD><I>Associates a <!1><A HREF="GMonitor.html">GMonitor</A> with this bitmap.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.5.17.1.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Accessing RLE data.</B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.6.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>rle_get_bits</B>(int rowno, unsigned char *bits) const 
<DD><I>Gets the pixels for line <TT>rowno</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.6.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>rle_get_runs</B>(int rowno, int *rlens) const 
<DD><I>Gets the lengths of all runs in line <TT>rowno</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.6.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>rle_get_rect</B>(<!1><A HREF="GRect.html">GRect</A> &amp;rect) const 
<DD><I>Gets the smallest rectangle enclosing black pixels.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.5.17.1.7"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Additive Blit.  </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.7.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>blit</B>(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> *bm, int x, int y)
<DD><I>Performs an additive blit of the GBitmap <TT>bm</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.7.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>blit</B>(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> *shape, int x, int y, int subsample)
<DD><I>Performs an additive blit of the GBitmap <TT>bm</TT> with anti-aliasing.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.5.17.1.8"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Saving images.  </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.8.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>save_pbm</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, int raw=1)
<DD><I>Saves the image into ByteStream <TT>bs</TT> using the PBM format.</I>
<DT>
<A HREF="#DOC.1.5.17.1.8.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>save_pgm</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, int raw=1)
<DD><I>Saves the image into ByteStream <TT>bs</TT> using the PGM format.</I>
<DT>
<A HREF="#DOC.1.5.17.1.8.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>save_rle</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs)
<DD><I>Saves the image into ByteStream <TT>bs</TT> using the RLE file format.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.5.17.1.9"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Stealing or borrowing the memory buffer (advanced). </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.5.17.1.9.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned char* <B>take_data</B>(size_t &amp;offset)
<DD><I>Steals the memory buffer of a GBitmap.</I>
<DT>
<A HREF="#DOC.1.5.17.1.9.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>inline   void <B>borrow_data</B>(unsigned char &amp;data, int w, int h)
<DD><I>Initializes this GBitmap by borrowing a memory segment.</I>
<DT>
<A HREF="#DOC.1.5.17.1.9.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>donate_data</B>(unsigned char *data, int w, int h)
<DD><I>Same as borrow_data, except GBitmap will call <TT>delete[]</TT>.</I>
<DT>
<A HREF="#DOC.1.5.17.1.9.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>const unsigned char* <B>get_rle</B>(unsigned int &amp;rle_length)
<DD><I>Return a pointer to the rle data.</I>
<DT>
<A HREF="#DOC.1.5.17.1.9.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>donate_rle</B>(unsigned char *rledata, unsigned int rledatalen, int w, int h)
<DD><I>Initializes this GBitmap by setting the size to <TT>h</TT> rows and <TT>w</TT> columns, and directly addressing the memory buffer <TT>rledata</TT> provided by the user.</I>
<DT>
<A HREF="#DOC.1.5.17.1.9.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>static inline   int <B>read_run</B>(const unsigned char *&amp;data)
<DD><I>Static function for parsing run data.</I>
<DT>
<A HREF="#DOC.1.5.17.1.9.7"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>static inline   void <B>append_run</B>(unsigned char *&amp;data, int <!1><A HREF="GPEnabled.html#DOC.1.5.4.1.6">count</A>)
<DD><I>Static function for generating run data.</I>
</DL></P>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="GPEnabled.html">GPEnabled</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="GPEnabled.html#DOC.1.5.4.1.2">GPEnabled</A>&amp; <B>operator=</B>(const <!1><A HREF="GPEnabled.html#DOC.1.5.4.1.2">GPEnabled</A> &amp; obj)
<DT>
<IMG ALT="o" SRC=icon2.gif>int <B>get_count</B>(void) const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>volatile   int <B>count</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU">
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>Bilevel and gray-level images.  Instances of class <TT>GBitmap</TT> represent
bilevel or gray-level images.  Images are usually represented using one
byte per pixel.  Value zero represents a white pixel.  A value equal to
the number of gray levels minus one represents a black pixel.  The number
of gray levels is returned by the function <!1><A HREF="GBitmap.html#DOC.1.5.17.1.4.1">get_grays</A> and can be
manipulated by the functions <!1><A HREF="GBitmap.html#DOC.1.5.17.1.4.2">set_grays</A> and <!1><A HREF="GBitmap.html#DOC.1.5.17.1.4.3">change_grays</A>.<P>The bracket operator returns a pointer to the bytes composing one line of
the image.  This pointer can be used to read or write the image pixels.
Line zero represents the bottom line of the image.<P>The memory organization is setup in such a way that you can safely read a
few pixels located in a small border surrounding all four sides of the
image.  The width of this border can be modified using the function
<!1><A HREF="GBitmap.html#DOC.1.5.17.1.3.6">minborder</A>.  The border pixels are initialized to zero and therefore
represent white pixels.  You should never write anything into border
pixels because they are shared between images and between lines.  </BLOCKQUOTE>
<DL>

<A NAME="Construction. ">
<A NAME="DOC.1.5.17.1.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Construction. </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="GBitmap">
<A NAME="DOC.1.5.17.1.1.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap()</B></TT>
<DD>Constructs an empty GBitmap object.  The returned GBitmap has zero rows
and zero columns.  Use function <!1><A HREF="GBitmap.html#DOC.1.5.17.1.2.2">init</A> to change the size of the
image. 
<DL><DT><DD></DL><P>
<A NAME="GBitmap">
<A NAME="DOC.1.5.17.1.1.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(int nrows, int ncolumns, int border=0)</B></TT>
<DD>Constructs a GBitmap with <TT>nrows</TT> rows and <TT>ncolumns</TT> columns.  All
pixels are initialized to white. The optional argument <TT>border</TT>
specifies the size of the optional border of white pixels surrounding
the image.  The number of gray levels is initially set to <TT>2</TT>.  
<DL><DT><DD></DL><P>
<A NAME="GBitmap">
<A NAME="DOC.1.5.17.1.1.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref)</B></TT>
<DD>Copy constructor. Constructs a GBitmap by replicating the size, the
border and the contents of GBitmap <TT>ref</TT>. 
<DL><DT><DD></DL><P>
<A NAME="GBitmap">
<A NAME="DOC.1.5.17.1.1.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref, int border)</B></TT>
<DD>Constructs a GBitmap by copying the contents of GBitmap <TT>ref</TT>.  
Argument <TT>border</TT> specifies the width of the optional border. 
<DL><DT><DD></DL><P>
<A NAME="GBitmap">
<A NAME="DOC.1.5.17.1.1.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref, const <!1><A HREF="GRect.html">GRect</A> &amp;rect, int border=0)</B></TT>
<DD>Constructs a GBitmap by copying a rectangular segment <TT>rect</TT> of GBitmap
<TT>ref</TT>.  The optional argument <TT>border</TT> specifies the size of the
optional border of white pixels surrounding the image. 
<DL><DT><DD></DL><P>
<A NAME="GBitmap">
<A NAME="DOC.1.5.17.1.1.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> GBitmap(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;ref, int border=0)</B></TT>
<DD>Constructs a GBitmap by reading PBM, PGM or RLE data from ByteStream
<TT>ref</TT> into this GBitmap. The optional argument <TT>border</TT> specifies the
size of the optional border of white pixels surrounding the image.  See
<!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A> for more information.  
<DL><DT><DD></DL><P></DL>

<A NAME="Initialization. ">
<A NAME="DOC.1.5.17.1.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Initialization. </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="init">
<A NAME="DOC.1.5.17.1.2.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(int nrows, int ncolumns, int border=0)</B></TT>
<DD>Resets this GBitmap size to <TT>nrows</TT> rows and <TT>ncolumns</TT> columns and sets
all pixels to white.  The optional argument <TT>border</TT> specifies the size
of the optional border of white pixels surrounding the image.  The
number of gray levels is initialized to <TT>2</TT>. 
<DL><DT><DD></DL><P>
<A NAME="init">
<A NAME="DOC.1.5.17.1.2.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref, int border=0)</B></TT>
<DD>Initializes this GBitmap with the contents of the GBitmap <TT>ref</TT>.  The
optional argument <TT>border</TT> specifies the size of the optional border of
white pixels surrounding the image. 
<DL><DT><DD></DL><P>
<A NAME="init">
<A NAME="DOC.1.5.17.1.2.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref, const <!1><A HREF="GRect.html">GRect</A> &amp;rect, int border=0)</B></TT>
<DD>Initializes this GBitmap with a rectangular segment <TT>rect</TT> of GBitmap
<TT>ref</TT>.  The optional argument <TT>border</TT> specifies the size of the
optional border of white pixels surrounding the image. 
<DL><DT><DD></DL><P>
<A NAME="init">
<A NAME="DOC.1.5.17.1.2.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;ref, int border=0)</B></TT>
<DD>Reads PBM, PGM or RLE data from ByteStream <TT>ref</TT> into this GBitmap.  The
previous content of the GBitmap object is lost. The optional argument
<TT>border</TT> specifies the size of the optional border of white pixels
surrounding the image. See <!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A> for more
information. 
<DL><DT><DD></DL><P>
<A NAME="operator=">
<A NAME="DOC.1.5.17.1.2.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A>&amp; operator=(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> &amp;ref)</B></TT>
<DD>Assignment operator. Initializes this GBitmap by copying the size, the
border and the contents of GBitmap <TT>ref</TT>. 
<DL><DT><DD></DL><P>
<A NAME="fill">
<A NAME="DOC.1.5.17.1.2.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void fill(unsigned char value)</B></TT>
<DD>Initializes all the GBitmap pixels to value <TT>value</TT>. 
<DL><DT><DD></DL><P></DL>

<A NAME="Accessing the pixels. ">
<A NAME="DOC.1.5.17.1.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Accessing the pixels. </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="rows">
<A NAME="DOC.1.5.17.1.3.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int rows() const </B></TT>
<DD>Returns the number of rows (the image height). 
<DL><DT><DD></DL><P>
<A NAME="columns">
<A NAME="DOC.1.5.17.1.3.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int columns() const </B></TT>
<DD>Returns the number of columns (the image width). 
<DL><DT><DD></DL><P>
<A NAME="operator[] ">
<A NAME="DOC.1.5.17.1.3.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const unsigned char* operator[] (int row) const </B></TT>
<DD>Returns a constant pointer to the first byte of row <TT>row</TT>.
This pointer can be used as an array to read the row elements. 
<DL><DT><DD></DL><P>
<A NAME="operator[] ">
<A NAME="DOC.1.5.17.1.3.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned char* operator[] (int row)</B></TT>
<DD>Returns a pointer to the first byte of row <TT>row</TT>.
This pointer can be used as an array to read or write the row elements. 
<DL><DT><DD></DL><P>
<A NAME="rowsize">
<A NAME="DOC.1.5.17.1.3.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int rowsize() const </B></TT>
<DD>Returns the size of a row in memory (in pixels).  This number is equal
to the difference between pointers to pixels located in the same column
in consecutive rows.  This difference can be larger than the number of
columns in the image. 
<DL><DT><DD></DL><P>
<A NAME="minborder">
<A NAME="DOC.1.5.17.1.3.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void minborder(int minimum)</B></TT>
<DD>Makes sure that the border is at least <TT>minimum</TT> pixels large.  This
function does nothing it the border width is already larger than
<TT>minimum</TT>.  Otherwise it reorganizes the data in order to provide a
border of <TT>minimum</TT> pixels. 
<DL><DT><DD></DL><P></DL>

<A NAME="Managing gray levels. ">
<A NAME="DOC.1.5.17.1.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Managing gray levels. </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="get_grays">
<A NAME="DOC.1.5.17.1.4.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int get_grays() const </B></TT>
<DD>Returns the number of gray levels. 
Value <TT>2</TT> denotes a bilevel image. 
<DL><DT><DD></DL><P>
<A NAME="set_grays">
<A NAME="DOC.1.5.17.1.4.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void set_grays(int grays)</B></TT>
<DD>Sets the number of gray levels without changing the pixels.
Argument <TT>grays</TT> must be in range <TT>2</TT> to <TT>256</TT>. 
<DL><DT><DD></DL><P>
<A NAME="change_grays">
<A NAME="DOC.1.5.17.1.4.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void change_grays(int grays)</B></TT>
<DD>Changes the number of gray levels.  The argument <TT>grays</TT> must be in the
range <TT>2</TT> to <TT>256</TT>.  All the pixel values are then rescaled and clipped
in range <TT>0</TT> to <TT>grays-1</TT>. 
<DL><DT><DD></DL><P>
<A NAME="binarize_grays">
<A NAME="DOC.1.5.17.1.4.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void binarize_grays(int threshold=0)</B></TT>
<DD>Binarizes a gray level image using a threshold.  The number of gray
levels is reduced to <TT>2</TT> as in a bilevel image.  All pixels whose value
was strictly greater than <TT>threshold</TT> are set to black. All other pixels
are set to white. 
<DL><DT><DD></DL><P></DL>

<A NAME="Optimizing the memory usage.  ">
<A NAME="DOC.1.5.17.1.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Optimizing the memory usage.  </B></TT>
<DD>The amount of memory used by bilevel images can be reduced using
function <!1><A HREF="GBitmap.html#DOC.1.5.17.1.5.1">compress</A>, which encodes the image using a run-length
encoding scheme.  The bracket operator decompresses the image on demand.
A few highly optimized functions (e.g. <!1><A HREF="GBitmap.html#DOC.1.5.17.1.7.1">blit</A>) can use a run-length
encoded bitmap without decompressing it.  There are unfortunate locking
issues associated with this capability (c.f. <!1><A HREF="GBitmap.html#DOC.1.5.17.1.5.5">share</A> and
<!1><A HREF="GBitmap.html#DOC.1.5.17.1.5.4">monitor</A>). 
<DL><DT><DD></DL><P><DL>

<A NAME="compress">
<A NAME="DOC.1.5.17.1.5.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void compress()</B></TT>
<DD>Reduces the memory required for a bilevel image by using a run-length
encoded representation.  Functions that need to access the pixel array
will decompress the image on demand. 
<DL><DT><DD></DL><P>
<A NAME="uncompress">
<A NAME="DOC.1.5.17.1.5.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void uncompress()</B></TT>
<DD>Decodes run-length encoded bitmaps and recreate the pixel array.
This function is usually called by <TT>operator[]</TT> when needed. 
<DL><DT><DD></DL><P>
<A NAME="get_memory_usage">
<A NAME="DOC.1.5.17.1.5.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned int get_memory_usage() const </B></TT>
<DD>Returns the number of bytes allocated for this image. 
<DL><DT><DD></DL><P>
<A NAME="monitor">
<A NAME="DOC.1.5.17.1.5.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GMonitor.html">GMonitor</A>* monitor() const </B></TT>
<DD>Returns a possibly null pointer to a <!1><A HREF="GMonitor.html">GMonitor</A> for this bitmap.
You should use this monitor to ensure that the data representation of the 
bitmap will not change while you are using it.  We suggest using
class GMonitorLock which properly handles null monitor pointers. 
<DL><DT><DD></DL><P>
<A NAME="share">
<A NAME="DOC.1.5.17.1.5.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void share()</B></TT>
<DD>Associates a <!1><A HREF="GMonitor.html">GMonitor</A> with this bitmap. This function should be
called on all bitmaps susceptible of being simultaneously used by
several threads.  It will make sure that function <!1><A HREF="GBitmap.html#DOC.1.5.17.1.5.4">monitor</A> returns
a pointer to a suitable monitor for this bitmap. 
<DL><DT><DD></DL><P></DL>

<A NAME="Accessing RLE data.">
<A NAME="DOC.1.5.17.1.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Accessing RLE data.</B></TT>
<DD>The next functions are useful for processing bilevel images
encoded using the run length encoding scheme.  These functions always return
zero if the bitmap is not RLE encoded.  Function <!1><A HREF="GBitmap.html#DOC.1.5.17.1.5.1">compress</A> must
be used to ensure that the bitmap is RLE encoded.  
<DL><DT><DD></DL><P><DL>

<A NAME="rle_get_bits">
<A NAME="DOC.1.5.17.1.6.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int rle_get_bits(int rowno, unsigned char *bits) const </B></TT>
<DD>Gets the pixels for line <TT>rowno</TT>.  One line of pixel is stored as
<TT>unsigned char</TT> values into array <TT>bits</TT>.  Each pixel is either 1 or 0.
The array must be large enough to hold the whole line.  The number of
pixels is returned. 
<DL><DT><DD></DL><P>
<A NAME="rle_get_runs">
<A NAME="DOC.1.5.17.1.6.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int rle_get_runs(int rowno, int *rlens) const </B></TT>
<DD>Gets the lengths of all runs in line <TT>rowno</TT>.  The array <TT>rlens</TT> must be
large enough to accomodate <TT>w+2</TT> integers where <TT>w</TT> is the number of
columns in the image.  These integers represent the lengths of
consecutive runs of alternatively white or black pixels.  Lengths can be
zero in order to allow for lines starting with black pixels.  This
function returns the total number of runs in the line. 
<DL><DT><DD></DL><P>
<A NAME="rle_get_rect">
<A NAME="DOC.1.5.17.1.6.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int rle_get_rect(<!1><A HREF="GRect.html">GRect</A> &amp;rect) const </B></TT>
<DD>Gets the smallest rectangle enclosing black pixels.
Rectangle rect gives the coordinates of the smallest rectangle
containing all black pixels. Returns the number of black pixels. 
<DL><DT><DD></DL><P></DL>

<A NAME="Additive Blit.  ">
<A NAME="DOC.1.5.17.1.7">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Additive Blit.  </B></TT>
<DD>The blit functions are designed to efficiently construct an anti-aliased
image by copying smaller images at predefined locations.  The image of a
page, for instance, is composed by copying the images of characters at
predefined locations.  These functions are fairly optimized.  They can
directly use compressed GBitmaps (see <!1><A HREF="GBitmap.html#DOC.1.5.17.1.5.1">compress</A>).  We consider in
this section that each GBitmap comes with a coordinate system defined as
follows.  Position (<TT>0</TT>,<TT>0</TT>) corresponds to the bottom left corner of
the bottom left pixel.  Position (<TT>1</TT>,<TT>1</TT>) corresponds to the top right
corner of the bottom left pixel, which is also the bottom left corner of
the second pixel of the second row.  Position (<TT>w</TT>,<TT>h</TT>), where <TT>w</TT> and
<TT>h</TT> denote the size of the GBitmap, corresponds to the top right corner
of the top right pixel. 
<DL><DT><DD></DL><P><DL>

<A NAME="blit">
<A NAME="DOC.1.5.17.1.7.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void blit(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> *bm, int x, int y)</B></TT>
<DD>Performs an additive blit of the GBitmap <TT>bm</TT>.  The GBitmap <TT>bm</TT> is
first positioned above the current GBitmap in such a way that position
(<TT>u</TT>,<TT>v</TT>) in GBitmap <TT>bm</TT> corresponds to position (<TT>u</TT>+<TT>x</TT>,<TT>v</TT>+<TT>y</TT>) in
the current GBitmap.  The value of each pixel in GBitmap <TT>bm</TT> is then
added to the value of the corresponding pixel in the current GBitmap.<P><B>Example</B>: Assume for instance that the current GBitmap is initially
white (all pixels have value zero).  This operation copies the pixel
values of GBitmap <TT>bm</TT> at position (<TT>x</TT>,<TT>y</TT>) into the current GBitmap.
Note that function <TT>blit</TT> does not change the number of gray levels in
the current GBitmap.  You may have to call <!1><A HREF="GBitmap.html#DOC.1.5.17.1.4.2">set_grays</A> to specify
how the pixel values should be interpreted. 
<DL><DT><DD></DL><P>
<A NAME="blit">
<A NAME="DOC.1.5.17.1.7.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void blit(const <!1><A HREF="GBitmap.html#DOC.1.5.17.1.1.1">GBitmap</A> *shape, int x, int y, int subsample)</B></TT>
<DD>Performs an additive blit of the GBitmap <TT>bm</TT> with anti-aliasing.  The
GBitmap <TT>bm</TT> is first positioned above the current GBitmap in such a
way that position (<TT>u</TT>,<TT>v</TT>) in GBitmap <TT>bm</TT> corresponds to position
(<TT>u</TT>+<TT>x</TT>/<TT>subsample</TT>,<TT>v</TT>+<TT>y</TT>/<TT>subsample</TT>) in the current GBitmap.  This
mapping results in a contraction of GBitmap <TT>bm</TT> by a factor
<TT>subsample</TT>.  Each pixel of the current GBitmap can be covered by a
maximum of <TT>subsample^2</TT> pixels of GBitmap <TT>bm</TT>.  The value of
each pixel in GBitmap <TT>bm</TT> is then added to the value of the
corresponding pixel in the current GBitmap.<P><B>Example</B>: Assume for instance that the current GBitmap is initially
white (all pixels have value zero).  Each pixel of the current GBitmap
then contains the sum of the gray levels of the corresponding pixels in
GBitmap <TT>bm</TT>.  There are up to <TT>subsample*subsample</TT> such pixels.  If
for instance GBitmap <TT>bm</TT> is a bilevel image (pixels can be <TT>0</TT> or <TT>1</TT>),
the pixels of the current GBitmap can take values in range <TT>0</TT> to
<TT>subsample*subsample</TT>.  Note that function <TT>blit</TT> does not change the
number of gray levels in the current GBitmap.  You must call
<!1><A HREF="GBitmap.html#DOC.1.5.17.1.4.2">set_grays</A> to indicate that there are <TT>subsample^2+1</TT> gray
levels.  Since there is at most 256 gray levels, this also means that
<TT>subsample</TT> should never be greater than <TT>15</TT>.<P><B>Remark</B>: Arguments <TT>x</TT> and <TT>y</TT> do not represent a position in the
coordinate system of the current GBitmap.  According to the above
discussion, the position is (<TT>x/subsample</TT>,<TT>y/subsample</TT>).  In other
words, you can position the blit with a sub-pixel resolution.  The
resulting anti-aliasing changes are paramount to the image quality. 
<DL><DT><DD></DL><P></DL>

<A NAME="Saving images.  ">
<A NAME="DOC.1.5.17.1.8">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Saving images.  </B></TT>
<DD>The following functions write PBM, PGM and RLE files.  PBM and PGM are
well known formats for bilevel and gray-level images.  The RLE is a
simple run-length encoding scheme for bilevel images. These files can be
read using the ByteStream based constructor or initialization function.
See <!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A> for more information. 
<DL><DT><DD></DL><P><DL>

<A NAME="save_pbm">
<A NAME="DOC.1.5.17.1.8.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void save_pbm(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, int raw=1)</B></TT>
<DD>Saves the image into ByteStream <TT>bs</TT> using the PBM format.  Argument
<TT>raw</TT> selects the ``Raw PBM'' (1) or the ``Ascii PBM'' (0) format.  The
image is saved as a bilevel image.  All non zero pixels are considered
black pixels. See section <!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A>. 
<DL><DT><DD></DL><P>
<A NAME="save_pgm">
<A NAME="DOC.1.5.17.1.8.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void save_pgm(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, int raw=1)</B></TT>
<DD>Saves the image into ByteStream <TT>bs</TT> using the PGM format.  Argument
<TT>raw</TT> selects the ``Raw PGM'' (1) or the ``Ascii PGM'' (0) format.  The
image is saved as a gray level image.  See section
<!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A>. 
<DL><DT><DD></DL><P>
<A NAME="save_rle">
<A NAME="DOC.1.5.17.1.8.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void save_rle(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs)</B></TT>
<DD>Saves the image into ByteStream <TT>bs</TT> using the RLE file format.
The image is saved as a bilevel image. All non zero pixels are
considered black pixels. See section <!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A>. 
<DL><DT><DD></DL><P></DL>

<A NAME="Stealing or borrowing the memory buffer (advanced). ">
<A NAME="DOC.1.5.17.1.9">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Stealing or borrowing the memory buffer (advanced). </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="take_data">
<A NAME="DOC.1.5.17.1.9.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>unsigned char* take_data(size_t &amp;offset)</B></TT>
<DD>Steals the memory buffer of a GBitmap.  This function returns the
address of the memory buffer allocated by this GBitmap object.  The
offset of the first pixel in the bottom line is written into variable
<TT>offset</TT>.  Other lines can be accessed using pointer arithmetic (see
<!1><A HREF="GBitmap.html#DOC.1.5.17.1.3.5">rowsize</A>).  The GBitmap object no longer ``owns'' the buffer: you
must explicitly de-allocate the buffer using <TT>operator delete []</TT>.  This
de-allocation should take place after the destruction or the
re-initialization of the GBitmap object.  This function will return a
null pointer if the GBitmap object does not ``own'' the buffer in the
first place.  
<DL><DT><DD></DL><P>
<A NAME="borrow_data">
<A NAME="DOC.1.5.17.1.9.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>inline   void borrow_data(unsigned char &amp;data, int w, int h)</B></TT>
<DD>Initializes this GBitmap by borrowing a memory segment.  The GBitmap
then directly addresses the memory buffer <TT>data</TT> provided by the user.
This buffer must be large enough to hold <TT>w*h</TT> bytes representing each
one pixel.  The GBitmap object does not ``own'' the buffer: you must
explicitly de-allocate the buffer using <TT>operator delete []</TT>.  This
de-allocation should take place after the destruction or the
re-initialization of the GBitmap object.  
<DL><DT><DD></DL><P>
<A NAME="donate_data">
<A NAME="DOC.1.5.17.1.9.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void donate_data(unsigned char *data, int w, int h)</B></TT>
<DD>Same as borrow_data, except GBitmap will call <TT>delete[]</TT>. 
<DL><DT><DD></DL><P>
<A NAME="get_rle">
<A NAME="DOC.1.5.17.1.9.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>const unsigned char* get_rle(unsigned int &amp;rle_length)</B></TT>
<DD>Return a pointer to the rle data. 
<DL><DT><DD></DL><P>
<A NAME="donate_rle">
<A NAME="DOC.1.5.17.1.9.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void donate_rle(unsigned char *rledata, unsigned int rledatalen, int w, int h)</B></TT>
<DD>Initializes this GBitmap by setting the size to <TT>h</TT> rows and <TT>w</TT>
columns, and directly addressing the memory buffer <TT>rledata</TT> provided by
the user.  This buffer contains <TT>rledatalen</TT> bytes representing the
bitmap in run length encoded form.  The GBitmap object then ``owns'' the
buffer (unlike <TT>borrow_data</TT>, but like <TT>donate_data</TT>) and will
deallocate this buffer when appropriate: you should not deallocate this
buffer yourself.  The encoding of buffer <TT>rledata</TT> is similar to the
data segment of the RLE file format (without the header) documented in
<!1><A HREF="PNMandRLEfileformats.html">PNM and RLE file formats</A>.  
<DL><DT><DD></DL><P>
<A NAME="read_run">
<A NAME="DOC.1.5.17.1.9.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static inline   int read_run(const unsigned char *&amp;data)</B></TT>
<DD>Static function for parsing run data.
This function returns one run length encoded at position <TT>data</TT> 
and increments the pointer <TT>data</TT> accordingly. 
<DL><DT><DD></DL><P>
<A NAME="append_run">
<A NAME="DOC.1.5.17.1.9.7">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static inline   void append_run(unsigned char *&amp;data, int <!1><A HREF="GPEnabled.html#DOC.1.5.4.1.6">count</A>)</B></TT>
<DD>Static function for generating run data.
This function encoded run length <TT>count</TT> at position <TT>data</TT>
and increments the pointer accordingly.  The pointer must
initially point to a large enough data buffer. 
<DL><DT><DD></DL><P></DL>
</DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I><P><HR>
<!-- This is were the DOC++ footer is defined  -->

<font face="arial,helvetica" size="2">
<a href=http://www.djvu.att.com>DjVu</a> is a trademark of AT&amp;T.  
<br>All other products mentioned are registered trademarks or trademarks of
their respective companies.
</font>
