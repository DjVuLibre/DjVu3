<HTML>
<HEAD>
   <TITLE>class  BSByteStream</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.1">
</HEAD>
<BODY BGCOLOR=#fefefe BACKGROUND=back.jpg>

<H2>class  <A HREF="#DOC.DOCU">BSByteStream</A>: public <!1><A HREF="ByteStream.html">ByteStream</A></H2>
<BLOCKQUOTE>Performs bzz compression/decompression.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CGPEnabled,MGPEnabled.html,CByteStream,MByteStream.html,CBSByteStream,MBSByteStream.html">
<param name=before value="M,M,M">
<param name=after value="Md_SP,Md_,M">
<param name=indent value="0,1,2">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<A HREF="#DOC.1.5.16.1.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>BSByteStream</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, int blocksize=0)
<DD><I>Constructs a BSByteStream.</I>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="ByteStream.html">ByteStream</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public</H3><DD><DT>
<P> <B>Virtual Functions.</B>
<P><DL>
<DT>
<A HREF="#DOC.1.5.12.1.1.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   <B>~ByteStream</B>()
<DD><I>Virtual destructor.</I>
<DT>
<A HREF="#DOC.1.5.12.1.1.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   size_t <B>read</B>(void *buffer, size_t size)
<DD><I>Reads data from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.1.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   size_t <B>write</B>(const void *buffer, size_t size)
<DD><I>Writes data to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.1.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   long <B>tell</B>(void)
<DD><I>Returns the offset of the current position in the ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.1.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   int <B>seek</B>(long offset, int whence = SEEK_SET, bool nothrow=false)
<DD><I>Sets the current position for reading or writing the ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.1.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>flush</B>()
<DD><I>Flushes all buffers in the ByteStream.</I>
</DL></P>
<DT>
<P> <B>Utility Functions.  </B>
<P><DL>
<DT>
<A HREF="#DOC.1.5.12.1.2.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>size_t <B>readall</B>(void *buffer, size_t size)
<DD><I>Reads data and blocks until everything has been read.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>size_t <B>writall</B>(const void *buffer, size_t size)
<DD><I>Writes data and blocks until everything has been written.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>size_t <B>copy</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bsfrom, size_t size=0)
<DD><I>Copy data from another ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write8</B>(unsigned int card8)
<DD><I>Writes a one-byte integer to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write16</B>(unsigned int card16)
<DD><I>Writes a two-bytes integer to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write24</B>(unsigned int card24)
<DD><I>Writes a three-bytes integer to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.7"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write32</B>(unsigned int card32)
<DD><I>Writes a four-bytes integer to a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.8"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>read8</B>()
<DD><I>Reads a one-byte integer from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.9"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>read16</B>()
<DD><I>Reads a two-bytes integer from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.10"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>read24</B>()
<DD><I>Reads a three-bytes integer from a ByteStream.</I>
<DT>
<A HREF="#DOC.1.5.12.1.2.11"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>unsigned int <B>read32</B>()
<DD><I>Reads a four-bytes integer from a ByteStream.</I>
</DL></P>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="GPEnabled.html">GPEnabled</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="GPEnabled.html#DOC.1.5.4.1.2">GPEnabled</A>&amp; <B>operator=</B>(const <!1><A HREF="GPEnabled.html#DOC.1.5.4.1.2">GPEnabled</A> &amp; obj)
<DT>
<IMG ALT="o" SRC=icon2.gif>int <B>get_count</B>(void) const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>volatile   int <B>count</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU">
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE>Performs bzz compression/decompression.<P>Class <TT>BSByteStream</TT> defines a <!1><A HREF="ByteStream.html">ByteStream</A> which transparently
performs the BZZ compression/decompression. The constructor of class
<!1><A HREF="BSByteStream.html#DOC.1.5.16.1.1">BSByteStream</A> takes another <!1><A HREF="ByteStream.html">ByteStream</A> as argument.  Any data
written to the BSByteStream is compressed and written to this second
ByteStream. Any data read from the BSByteStream is internally generated by
decompressing data read from the second ByteStream.<P>Program <!1><A HREF="bzz.html">bzz</A> demonstrates how to use this class.  All the hard work
is achieved by a simple ByteStream to ByteStream copy, as shown below.
<PRE>
      StdioByteStream in(infile,&quot;rb&quot;);
      StdioByteStream out(outfile,&quot;wb&quot;);
      if (encoding) {
          BSByteStream bsb(&amp;out, blocksize);
          bsb.copy(in);
      } else {
          BSByteStream bsb(&amp;in);
          out.copy(bsb);
      }
    </PRE>
Due to the block oriented nature of the Burrows-Wheeler transform, there
is a very significant latency between the data input and the data output.
You can use function <TT>flush</TT> to force data output at the expense of
compression efficiency.<P>You should never directly access a ByteStream object connected to a valid
BSByteStream object. The ByteStream object can be accessed again after the
destruction of the BSByteStream object.  Note that the encoder always
flushes its internal buffers and writes a few final code bytes when the
BSByteStream object is destroyed.  Note also that the decoder often reads
a few bytes beyond the last code byte written by the encoder.  This lag
means that you must reposition the ByteStream after the destruction of the
BSByteStream object and before re-using the ByteStream object (see
<!1><A HREF="IFFByteStream.html">IFFByteStream</A>.)</BLOCKQUOTE>
<DL>

<A NAME="BSByteStream">
<A NAME="DOC.1.5.16.1.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> BSByteStream(<!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, int blocksize=0)</B></TT>
<DD>Constructs a BSByteStream.
Argument <TT>blocksize</TT> determines whether the BSByteStream will be used
for compressing or decompressing data. 
<DL>
<DT><B>Decompression</B><DD>
Setting <TT>blocksize</TT> to zero initializes the decompressor.  Chunks of
data will be read from ByteStream <TT>bs</TT> and decompressed into an internal
buffer. Function <TT>read</TT> can be used to access the decompressed data.
<DT><B>Compression</B><DD>
Setting <TT>blocksize</TT> to a positive number smaller than 4096
initializes the compressor.  Data written to the BSByteStream will be
accumulated into an internal buffer.  The buffered data will be
compressed and written to ByteStream <TT>bs</TT> whenever the buffer sizes
reaches the maximum value specified by argument <TT>blocksize</TT> (in
kilobytes).  Using a larger block size usually increases the compression
ratio at the expense of computation time.  There is no need however to
specify a block size larger than the total number of bytes to compress.
Setting <TT>blocksize</TT> to <TT>1024</TT> is a good starting point.  A minimal block
size of 10 is silently enforced.
</DL> 
<DL><DT><DD></DL><P></DL>

<HR><DL><DT><B>This class has no child classes.</B></DL>

<DL><DT><DD></DL><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I><P><HR>
<!-- This is were the DOC++ footer is defined  -->

<font face="arial,helvetica" size="2">
DjVu is a trademark of LizardTech.   
<br>All other products mentioned are registered trademarks or trademarks of
their respective companies.
</font>
