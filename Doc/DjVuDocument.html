<HTML>
<HEAD>
   <TITLE>class  ByteStream::DjVuDocument</TITLE>
   <META NAME="GENERATOR" CONTENT="DOC++ 3.4.1">
</HEAD>
<BODY BGCOLOR=#fefefe BACKGROUND=back.jpg>

<H2>class  <A HREF="#DOC.DOCU">DjVuDocument</A>: public <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A></H2>
<BLOCKQUOTE><TT>DjVuDocument</TT> provides convenient interface for opening, decoding and saving back DjVu documents in single page and multi page formats.</BLOCKQUOTE>
<HR>

<H2>Inheritance:</H2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=125>
<param name=classes value="CGPEnabled,MGPEnabled.html,CDjVuPort,MDjVuPort.html,CDjVuDocument,MDjVuDocument.html,CDjVuDocEditor,MDjVuDocEditor.html">
<param name=before value="M,M,M,M^_">
<param name=after value="Md_SP,Md_,M,M">
<param name=indent value="0,1,2,2">
<param name=arrowdir value="down">
</APPLET>
<HR>

<DL>
<P><DL>
<DT><H3>Public Classes</H3><DD><DT>
<A HREF="#DOC.1.4.29.1.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>enum  <B>DOC_FLAGS</B>
<DD><I>Flags describing the document initialization state.</I>
<DT>
<A HREF="#DOC.1.4.29.1.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>enum  <B>DOC_TYPE</B>
<DD><I>Specifies the format of <TT>DjVuDocument</TT>.</I>
</DL></P>

<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<A HREF="#DOC.1.4.29.1.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>DjVuDocument</B>(void)
<DD><I>Default constructor.</I>
<DT>
<A HREF="#DOC.1.4.29.1.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>start_init</B>(const <!1><A HREF="GURL.html">GURL</A> &amp; url, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; port=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * cache=0)
<DD><I>Initializes the <TT>DjVuDocument</TT> object using an existing document.</I>
<DT>
<A HREF="#DOC.1.4.29.1.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>static   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.3">DjVuDocument</A>&gt;  <B>create</B>( const <!1><A HREF="GURL.html">GURL</A> &amp;url, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; xport=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * const xcache=0)
<DD><I>Create a version of DjVuDocument which has begun initializing.</I>
<DT>
<A HREF="#DOC.1.4.29.1.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>static   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.3">DjVuDocument</A>&gt;  <B>create</B>( <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DataPool.html">DataPool</A>&gt; pool, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; xport=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * const xcache=0)
<DD><I>Create a version of DjVuDocument which has begun initializing.</I>
<DT>
<A HREF="#DOC.1.4.29.1.7"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>static   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.3">DjVuDocument</A>&gt;  <B>create</B>( <!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; xport=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * const xcache=0)
<DD><I>Create a version of DjVuDocument which has begun initializing.</I>
<DT>
<A HREF="#DOC.1.4.29.1.8"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>stop_init</B>(void)
<DD><I>Call this function when you don't need the <TT>DjVuDocument</TT> any more.</I>
<DT>
<A HREF="#DOC.1.4.29.1.9"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>init</B>(const <!1><A HREF="GURL.html">GURL</A> &amp; url, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; port=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * cache=0)
<DD><I>Initializes the document.</I>
<DT>
<A HREF="#DOC.1.4.29.1.10"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>is_init_complete</B>(void) const 
<DD><I>Returns <TT>TRUE</TT> if the initialization thread finished (does not matter successfully or not).</I>
<DT>
<A HREF="#DOC.1.4.29.1.11"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>is_init_ok</B>(void) const 
<DD><I>Returns <TT>TRUE</TT> is the initialization thread finished successfully.</I>
<DT>
<A HREF="#DOC.1.4.29.1.12"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>set_needs_compression</B>(void)
<DD><I>Forces compression with the next save_as function.</I>
<DT>
<A HREF="#DOC.1.4.29.1.13"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>needs_compression</B>(void) const 
<DD><I>Returns <TT>TRUE</TT> if there are uncompressed pages in this document.</I>
<DT>
<A HREF="#DOC.1.4.29.1.14"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>needs_rename</B>(void) const 
<DD><I>Returns <TT>TRUE</TT> if this file must be renamed before saving.</I>
<DT>
<A HREF="#DOC.1.4.29.1.15"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>can_compress</B>(void) const 
<DD><I>Returns <TT>TRUE</TT> if this file must be renamed before saving.</I>
<DT>
<A HREF="#DOC.1.4.29.1.16"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>is_init_failed</B>(void) const 
<DD><I>Returns <TT>TRUE</TT> is the initialization thread failed.</I>
<DT>
<A HREF="#DOC.1.4.29.1.17"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>get_doc_type</B>(void) const 
<DD><I>If the document has already learnt its type, the function will returns it: <TT>DjVuDocument::OLD_BUNDLED</TT> or <TT>DjVuDocument::OLD_INDEXED</TT> or <TT>DjVuDocument::SINGLE_PAGE</TT> or <TT>DjVuDocument:BUNDLED</TT> or <TT>DjVuDocument::INDIRECT</TT>.</I>
<DT>
<A HREF="#DOC.1.4.29.1.18"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>long <B>get_doc_flags</B>(void) const 
<DD><I>Returns the document flags.</I>
<DT>
<A HREF="#DOC.1.4.29.1.19"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>is_bundled</B>(void) const 
<DD><I>Returns <TT>TRUE</TT> if the document is in bundled format (either in <TT>DjVuDocument::OLD_BUNDLED</TT> or <TT>DjVuDocument::BUNDLED</TT> formats).</I>
<DT>
<A HREF="#DOC.1.4.29.1.28"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GURL.html">GURL</A> <B>get_init_url</B>(void) const 
<DD><I>Returns the URL passed to the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function</I>
<DT>
<A HREF="#DOC.1.4.29.1.20"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DataPool.html">DataPool</A>&gt;  <B>get_init_data_pool</B>(void) const 
<DD><I>Returns data corresponding to the URL passed to the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function.</I>
<DT>
<A HREF="#DOC.1.4.29.1.22"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>bool <B>wait_for_complete_init</B>(void)
<DD><I>Waits until the document initialization process finishes.</I>
<DT>
<A HREF="#DOC.1.4.29.1.23"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>wait_get_pages_num</B>(void)
<DD><I>Wait until we known the number of pages and return.</I>
<DT>
<A HREF="#DOC.1.4.29.1.29"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="DjVuFileCache.html">DjVuFileCache</A>* <B>get_cache</B>(void) const 
<DD><I>Returns cache being used.</I>
<DT>
<A HREF="#DOC.1.4.29.1.25"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVmDir.html">DjVmDir</A>&gt;  <B>get_djvm_dir</B>(void) const 
<DD><I>Returns pointer to the internal directory of the document, if it is in one of the new formats: <TT>BUNDLED</TT> or <TT>INDIRECT</TT>.</I>
<DT>
<A HREF="#DOC.1.4.29.1.26"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVmDir0.html">DjVmDir0</A>&gt;  <B>get_djvm_dir0</B>(void) const 
<DD><I>Returns pointer to the internal directory of the document, if it is in obsolete <TT>OLD_BUNDLED</TT> format.</I>
<DT>
<A HREF="#DOC.1.4.29.1.27"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuNavDir.html">DjVuNavDir</A>&gt;  <B>get_nav_dir</B>(void) const 
<DD><I>Returns pointer to <EM>navigation directory</EM> of the document.</I>
<DT>
<A HREF="#DOC.1.4.29.1.30"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   bool <B>inherits</B>(const char * class_name) const 
<DD><I>Returns TRUE if <TT>class_name</TT> is <TT>&quot;DjVuDocument&quot;</TT> or <TT>&quot;DjVuPort&quot;</TT></I>
</DL></P>

<P><DL>
<DT><H3>Public</H3><DD><DT>
<A HREF="#DOC.1.4.29.1.21"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Accessing pages </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.4.29.1.21.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>get_pages_num</B>(void) const 
<DD><I>Returns the number of pages in the document.</I>
<DT>
<A HREF="#DOC.1.4.29.1.21.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GURL.html">GURL</A> <B>page_to_url</B>(int page_num) const 
<DD><I>Translates the page number to the full URL of the page.</I>
<DT>
<A HREF="#DOC.1.4.29.1.21.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>int <B>url_to_page</B>(const <!1><A HREF="GURL.html">GURL</A> &amp; url) const 
<DD><I>Translates the page URL back to page number.</I>
<DT>
<A HREF="#DOC.1.4.29.1.21.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GURL.html">GURL</A> <B>id_to_url</B>(const char * id) const 
<DD><I>Translates the textual ID to the complete URL if possible.</I>
<DT>
<A HREF="#DOC.1.4.29.1.21.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuImage.html">DjVuImage</A>&gt;  <B>get_page</B>(int page_num, bool sync=true, <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * port=0)
<DD><I>Returns <!1><A HREF="GP.html">GP</A> pointer to <!1><A HREF="DjVuImage.html">DjVuImage</A> corresponding to page <TT>page_num</TT>.</I>
<DT>
<A HREF="#DOC.1.4.29.1.21.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuImage.html">DjVuImage</A>&gt;  <B>get_page</B>(const char * id, bool sync=true, <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * port=0)
<DD><I>Returns <!1><A HREF="GP.html">GP</A> pointer to <!1><A HREF="DjVuImage.html">DjVuImage</A> corresponding to the specified ID.</I>
<DT>
<A HREF="#DOC.1.4.29.1.21.7"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuFile.html">DjVuFile</A>&gt;  <B>get_djvu_file</B>(int page_num, bool dont_create=false)
<DD><I>Returns <!1><A HREF="DjVuFile.html">DjVuFile</A> corresponding to the specified page.</I>
<DT>
<A HREF="#DOC.1.4.29.1.21.8"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuFile.html">DjVuFile</A>&gt;  <B>get_djvu_file</B>(const char * id, bool dont_create=false)
<DD><I>Returns <!1><A HREF="DjVuFile.html">DjVuFile</A> corresponding to the specified ID.</I>
<DT>
<A HREF="#DOC.1.4.29.1.21.9"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DataPool.html">DataPool</A>&gt;  <B>get_thumbnail</B>(int page_num, bool dont_decode)
<DD><I>Returns a <!1><A HREF="DataPool.html">DataPool</A> containing one chunk <TT>TH44</TT> with the encoded thumbnail for the specified page.</I>
</DL></P>
<DT>
<A HREF="#DOC.1.4.29.1.24"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A> <B>Saving document to disk </B>
<DD><I></I>
<P><DL>
<DT>
<A HREF="#DOC.1.4.29.1.24.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVmDoc.html">DjVmDoc</A>&gt;  <B>get_djvm_doc</B>(void)
<DD><I>Returns pointer to the <!1><A HREF="DjVmDoc.html">DjVmDoc</A> class, which can save the document contents on the hard disk in one of the two new formats: <EM>bundled</EM> and <EM>indirect</EM>.</I>
<DT>
<A HREF="#DOC.1.4.29.1.24.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>write</B>(<!1><A HREF="ByteStream.html">ByteStream</A> &amp; str, bool force_djvm=false)
<DD><I>Saves the document in the <EM>new bundled</EM> format.</I>
<DT>
<A HREF="#DOC.1.4.29.1.24.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>void <B>expand</B>(const char * dir_name, const char * idx_name)
<DD><I>Saves the document in the <EM>new indirect</EM> format when every page and component are stored in separate files.</I>
<DT>
<A HREF="#DOC.1.4.29.1.24.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>save_as</B>(const char where[], const bool bundled=0)
<DD><I>This function can be used instead of <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.24.2">write</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.24.3">expand</A>().</I>
</DL></P>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="DjVuPort.html">DjVuPort</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>static   <!1><A HREF="DjVuPortcaster.html">DjVuPortcaster</A>* <B>get_portcaster</B>(void)
<DT>
<IMG ALT="o" SRC=icon2.gif><!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&amp; <B>operator=</B>(const <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> &amp; port)
</DL></P>

<P><DL>
<DT><H3>Public</H3><DD><DT>
<P> <B>Notifications. </B>
<P><DL>
<DT>
<A HREF="#DOC.1.4.26.1.5.1"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   <!1><A HREF="GURL.html">GURL</A> <B>id_to_url</B>(const <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * source, const char * id)
<DD><I>This request is issued to request translation of the ID, used in an DjVu INCL chunk to a URL, which may be used to request data associated with included file.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.2"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   <!1><A HREF="GPBase.html">GPBase</A> <B>id_to_file</B>(const <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * source, const char * id)
<DD><I>This request is used to get a file corresponding to the given ID.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.3"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DataPool.html">DataPool</A>&gt;  <B>request_data</B>(const <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * source, const <!1><A HREF="GURL.html">GURL</A> &amp; url)
<DD><I>This request is issued when decoder needs additional data for decoding.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.4"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   bool <B>notify_error</B>(const <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * source, const char * msg)
<DD><I>This notification is sent when an error occurs and the error message should be shown to the user.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.5"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   bool <B>notify_status</B>(const <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * source, const char * msg)
<DD><I>This notification is sent to update the decoding status.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.6"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>notify_redisplay</B>(const class <!1><A HREF="DjVuImage.html">DjVuImage</A> * source)
<DD><I>This notification is sent by <!1><A HREF="DjVuImage.html">DjVuImage</A> when it should be redrawn.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.7"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>notify_relayout</B>(const class <!1><A HREF="DjVuImage.html">DjVuImage</A> * source)
<DD><I>This notification is sent by \ref{DjVuImage} when its geometry has been changed as a result of decoding.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.8"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>notify_chunk_done</B>(const <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * source, const char * name)
<DD><I>This notification is sent when a new chunk has been decoded.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.9"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>notify_file_flags_changed</B>(const class <!1><A HREF="DjVuFile.html">DjVuFile</A> * source, long set_mask, long clr_mask)
<DD><I>This notification is sent after the <!1><A HREF="DjVuFile.html">DjVuFile</A> flags have been changed.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.10"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>notify_doc_flags_changed</B>(const class <!1><A HREF="DjVuDocument.html">DjVuDocument</A> * source, long set_mask, long clr_mask)
<DD><I>This notification is sent after the <!1><A HREF="DjVuDocument.html">DjVuDocument</A> flags have been changed.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.11"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>virtual   void <B>notify_decode_progress</B>(const <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * source, float done)
<DD><I>This notification is sent from time to time while decoding is in progress.</I>
<DT>
<A HREF="#DOC.1.4.26.1.5.12"><IMG ALT="[more]" BORDER=0 SRC=icon1.gif></A>enum  <B>ErrorRecoveryAction</B>
<DD><I>This is the standard types for defining what to do in case of errors.</I>
</DL></P>
</DL></P>

</DL>
<HR><H3>Inherited from <A HREF="GPEnabled.html">GPEnabled</A>:</H3>
<DL>
<P><DL>
<DT><H3>Public Methods</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>int <B>get_count</B>(void) const 
</DL></P>

<P><DL>
<DT><H3>Protected Fields</H3><DD><DT>
<IMG ALT="o" SRC=icon2.gif>volatile   int <B>count</B>
</DL></P>

</DL>

<A NAME="DOC.DOCU">
<HR>
<H2>Documentation</H2>
<BLOCKQUOTE><TT>DjVuDocument</TT> provides convenient interface for opening, decoding
and saving back DjVu documents in single page and multi page formats.<P><B>Input formats</B>
It can read multi page DjVu documents in either of the 4 formats: 2
obsolete (<EM>old bundled</EM> and <EM>old indexed</EM>) and two new
(<EM>new bundled</EM> and <EM>new indirect</EM>).<P><B>Output formats</B>
To encourage users to switch to the new formats, the <TT>DjVuDocument</TT> can
save documents back only in the new formats: <EM>bundled</EM> and
<EM>indirect</EM>.<P><B>Conversion.</B> Since <TT>DjVuDocument</TT> can open DjVu documents in
an obsolete format and save it in any of the two new formats
(<EM>new bundled</EM> and <EM>new indirect</EM>), this class can be used for
conversion from obsolete formats to the new ones. Although it can also
do conversion between the new two formats, it's not the best way to
do it. Please refer to <!1><A HREF="DjVmDoc.html">DjVmDoc</A> for details.<P><B>Decoding.</B> <TT>DjVuDocument</TT> provides convenient interface for obtaining
<!1><A HREF="DjVuImage.html">DjVuImage</A> corresponding to any page of the document. It uses
<!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> to do caching thus avoiding unnecessary multiple decoding of
the same page. The real decoding though is accomplished by <!1><A HREF="DjVuFile.html">DjVuFile</A>.<P><B>Messenging.</B> Being derived from <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>, <TT>DjVuDocument</TT>
takes an active part in exchanging messages (requests and notifications)
between different parties involved in decoding. It reports (relays)
errors, progress information and even handles some requests for data (when
these requests deal with local files).<P>Typical usage of <TT>DjVuDocument</TT> class in a threadless command line
program would be the following:
<PRE>
    GString file_name=&quot;/tmp/document.djvu&quot;;
    GP&lt;DjVuDocument&gt; doc=new DjVuDocument;
    doc-&gt;init(GOS::filename_to_url(file_name));
    int pages=doc-&gt;get_pages_num();
    for(int page=0;page&lt;pages;page++)
    {
       GP&lt;DjVuImage&gt; dimg=doc-&gt;get_page(page);
       // Do something
    };
    </PRE><P><B>Comments for the code above</B>
<OL>
<LI> Since the document is assumed to be stored on the hard drive,
we don't have to cope with <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>s and can pass
<TT>ZERO</TT> pointer to the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function. <TT>DjVuDocument</TT>
can access local data itself. In the case of a plugin though,
one would have to implement his own <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>, which
would handle requests for data arising when the document
is being decoded.
<LI> In a threaded program instead of calling the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>()
function one can call <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.4">start_init</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.8">stop_init</A>()
to initiate and interrupt initialization carried out in
another thread. This possibility of initializing the document
in another thread has been added specially for the plugin
because the initialization itself requires data, which is
not immediately available in the plugin. Thus, to prevent the
main thread from blocking, we perform initialization in a
separate thread. To check if the class is completely and
successfully initialized, use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.11">is_init_ok</A>(). To see if
there was an error, use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.16">is_init_failed</A>(). To
know when initialization is over (whether successfully or not),
use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.10">is_init_complete</A>(). To wait for this to happen use
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>(). Once again, all these things are
not required for single-threaded program.<P>Another difference between single-threaded and multi-threaded
environments is that in a single-threaded program, the image is
fully decoded before it's returned. In a multi-threaded
application decoding starts in a separate thread, and the pointer
to the <!1><A HREF="DjVuImage.html">DjVuImage</A> being decoded is returned immediately.
This has been done to enable progressive redisplay
in the DjVu plugin. Use communication mechanism provided by
<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> and <!1><A HREF="DjVuPortcaster.html">DjVuPortcaster</A> to learn about progress
of decoding.  Or try <TT>dimg-&gt;wait_for_complete_decode()</TT> to wait
until the decoding ends.
<LI> See Also: <!1><A HREF="DjVuFile.html">DjVuFile</A>, <!1><A HREF="DjVuImage.html">DjVuImage</A>, <!1><A HREF="GOS.html">GOS</A>.
</OL><P><B>Initialization</B>
As mentioned above, the <TT>DjVuDocument</TT> can go through several stages
of initialization. The functionality is gradually added while it passes
one stage after another:
<OL>
<LI> First of all, immediately after the object is created <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>()
or <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.4">start_init</A>() functions must be called. <B>Nothing</B>
will work until this is done. <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function will not
return until the initialization is complete. You need to make
sure, that enough data is available. <B>Do not call <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>()
in the plugin</B>. <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.4">start_init</A>() will start initialization
in another thread. Use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.8">stop_init</A>() to interrupt it.
Use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.10">is_init_complete</A>() to check the initialization progress.
Use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>() to wait for init to finish.
<LI> The first thing the initializing code learns about the document
is its type (<TT>BUNDLED</TT>, <TT>INDIRECT</TT>, <TT>OLD_BUNDLED</TT> or <TT>OLD_INDEXED</TT>).
As soon as it happens, document flags are changed and
<TT>notify_doc_flags_changed()</TT> request is sent through the
communication mechanism provided by <!1><A HREF="DjVuPortcaster.html">DjVuPortcaster</A>.
<LI> After the document type becomes known, the initializing code
proceeds with learning the document structure. Gradually the
flags are updated with values:
<UL>
<LI> <TT>DOC_DIR_KNOWN</TT>: Contents of the document became known.
This is meaningful for <TT>BUNDLED</TT>, <TT>OLD_BUNDLED</TT> and
<TT>INDIRECT</TT> documents only.
<LI> <TT>DOC_NDIR_KNOWN</TT>: Contents of the document navigation
directory became known. This is meaningful for old-style
documents (<TT>OLD_BUNDLED</TT> and <TT>OLD_INDEXED</TT>) only
<LI> <TT>DOC_INIT_OK</TT> or <TT>DOC_INIT_FAILED</TT>:
The initializating code finished.
</UL>
</OL> </BLOCKQUOTE>
<DL>

<A NAME="DOC_FLAGS">
<A NAME="DOC.1.4.29.1.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  DOC_FLAGS</B></TT>
<DD>Flags describing the document initialization state.
<UL>
<LI> <TT>DOC_TYPE_KNOWN</TT>: The type of the document has been learnt.
<LI> <TT>DOC_DIR_KNOWN</TT>: Contents of the document became known.
This is meaningful for <TT>BUNDLED</TT>, <TT>OLD_BUNDLED</TT> and
<TT>INDIRECT</TT> documents only.
<LI> <TT>DOC_NDIR_KNOWN</TT>: Contents of the document navigation
directory became known. This is meaningful for old-style
documents (<TT>OLD_BUNDLED</TT> and <TT>OLD_INDEXED</TT>) only
<LI> <TT>DOC_INIT_OK</TT>: The initialization has completed successfully.
<LI> <TT>DOC_INIT_FAILED</TT>: The initialization failed.
</UL> 
<DL><DT><DD></DL><P>
<A NAME="DOC_TYPE">
<A NAME="DOC.1.4.29.1.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>enum  DOC_TYPE</B></TT>
<DD>Specifies the format of <TT>DjVuDocument</TT>. There are currently 4 DjVu
multipage formats recognized by the library. Two of them are obsolete
and should not be used.
<OL>
<LI> <TT>OLD_BUNDLED</TT> - Obsolete bundled format
<LI> <TT>OLD_INDEXED</TT> - Obsolete multipage format where every page
is stored in a separate file and "includes" (by means
of an <TT>INCL</TT> chunk) the file with the document directory.
<LI> <TT>SINGLE_PAGE</TT> - Single page document. Basically a file
with either <TT>FORM:DJVU</TT> or <TT>FORM:IW44</TT> and no multipage
information. For example, <TT>OLD_INDEXED</TT> documents with
document directory do not qualify even if they contain only
one page.
<LI> <TT>BUNDLED</TT> - Currently supported bundled format
<LI> <TT>INDIRECT</TT> - Currently supported "expanded" format, where
every page and component is stored in a separate file. There
is also a <EM>top-level</EM> file with the document directory.
</OL> 
<DL><DT><DD></DL><P>
<A NAME="DjVuDocument">
<A NAME="DOC.1.4.29.1.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> DjVuDocument(void)</B></TT>
<DD>Default constructor. Please call functions <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() or
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.4">start_init</A>() before you start working with the <TT>DjVuDocument</TT>. 
<DL><DT><DD></DL><P>
<A NAME="start_init">
<A NAME="DOC.1.4.29.1.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void start_init(const <!1><A HREF="GURL.html">GURL</A> &amp; url, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; port=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * cache=0)</B></TT>
<DD>Initializes the <TT>DjVuDocument</TT> object using an existing document.
This function should be called once after creating the object.
The <TT>url</TT> should point to the real data, and the creator of the
document should be ready to return this data to the document
if it's not stored locally (in which case <TT>DjVuDocument</TT> can
access it itself).<P><B>Initializing thread</B>
In a single-threaded application, the <TT>start_init()</TT> function performs
the complete initialization of the <TT>DjVuDocument</TT> before it returns.
In a multi-threaded application, though, it initializes some internal
variables, requests data for the document and starts a new
<EM>initializing</EM> thread, which is responsible for determining the
document type and structure and completing the initialization
process. This additional complication is justified in the case of
the DjVu plugin because performing initialization requires data and
in the plugin the data can be supplied by the main thread only.
Thus, if the initialization was completed by the main thread, the
plugin would run out of data and block.<P><B>Stages of initialization</B>
Immediately after the <TT>start_init()</TT> function terminates, the
<TT>DjVuDocument</TT> object is ready for use. Its functionality will
not be complete (until the initializing thread finishes), but
the object is still very useful. Such functions as <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.5">get_page</A>()
or <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.7">get_djvu_file</A>() or <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.4">id_to_url</A>() may be called
before the initializing thread completes. This allows the DjVu
plugin start decoding as soon as possible without waiting for
all data to arrive.<P>To query the current stage of initialization you can use
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.18">get_doc_flags</A>() function or listen to the
<TT>notify_doc_flags_changed()</TT> notifications distributed with the help
of <!1><A HREF="DjVuPortcaster.html">DjVuPortcaster</A>. To wait for the initialization to
complete use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>(). To stop initialization
call <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.8">stop_init</A>().<P><B>Querying data</B>
The query for data is done using the communication mechanism
provided by <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> and <!1><A HREF="DjVuPortcaster.html">DjVuPortcaster</A>. If <TT>port</TT>
is not <TT>ZERO</TT>, then the request for data will be forwarded to it.
If it <B>is</B> <TT>ZERO</TT> then <TT>DjVuDocument</TT> will create an internal
instance of <!1><A HREF="DjVuSimplePort.html">DjVuSimplePort</A> and will use it to access local
files and report errors to <TT>stderr</TT>. In short, if the document
file is stored on the local hard disk, and you're OK about reporting
errors to <TT>stderr</TT>, you may pass <TT>ZERO</TT> pointer to <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>
as <TT>DjVuDocument</TT> can take care of this situation by itself.<P><B>The URL</B>
Depending on the document type the <TT>url</TT> should point to:
<UL>
<LI> <B>Old bundled</B> and <B>New bundled</B> formats: to the
document itself.
<LI> <B>Old indexed</B> format: to any page of the document.
<LI> <B>New indirect</B> format: to the top-level file of the
document. If (like in the <EM>old indexed</EM> format) you
point the <TT>url</TT> to a page, the page <EM>will</EM> be decoded,
but it will <EM>not</EM> be recognized to be part of the
document.
</UL><P>
<DL><DT><DT><B>Parameters:</B><DD><B>url</B> -  The URL pointing to the document. If the document is
in a <EM>bundled</EM> format then the URL should point to it.
If the document is in the <EM>old indexed</EM> format then
URL may point to any page of this document. For <EM>new
indirect</EM> format the URL should point to the top-level
file of the document.
<BR><B>port</B> -  If not <TT>ZERO</TT>, all requests and notifications will
be sent to it. Otherwise <TT>DjVuDocument</TT> will create an internal
instance of <!1><A HREF="DjVuSimplePort.html">DjVuSimplePort</A> for these purposes.
It's OK to make it <TT>ZERO</TT> if you're writing a command line
tool, which should work with files on the hard disk only
because <TT>DjVuDocument</TT> can access such files itself.
<BR><B>cache</B> -  It's used to cache decoded <!1><A HREF="DjVuFile.html">DjVuFile</A>s and
is actually useful in the plugin only.  <BR><DD></DL><P>
<A NAME="create">
<A NAME="DOC.1.4.29.1.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.3">DjVuDocument</A>&gt;  create( const <!1><A HREF="GURL.html">GURL</A> &amp;url, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; xport=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * const xcache=0)</B></TT>
<DD>Create a version of DjVuDocument which has begun initializing. 
<DL><DT><DD></DL><P>
<A NAME="create">
<A NAME="DOC.1.4.29.1.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.3">DjVuDocument</A>&gt;  create( <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DataPool.html">DataPool</A>&gt; pool, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; xport=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * const xcache=0)</B></TT>
<DD>Create a version of DjVuDocument which has begun initializing. 
<DL><DT><DD></DL><P>
<A NAME="create">
<A NAME="DOC.1.4.29.1.7">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>static   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.3">DjVuDocument</A>&gt;  create( <!1><A HREF="ByteStream.html">ByteStream</A> &amp;bs, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; xport=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * const xcache=0)</B></TT>
<DD>Create a version of DjVuDocument which has begun initializing. 
<DL><DT><DD></DL><P>
<A NAME="stop_init">
<A NAME="DOC.1.4.29.1.8">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void stop_init(void)</B></TT>
<DD>Call this function when you don't need the <TT>DjVuDocument</TT> any more.
In a multi-threaded environment it will stop initialization
thread, if it is currently running. <B>You will not be able
to start the initialization again. Thus, after calling this
function the document should not be used any more</B>. 
<DL><DT><DD></DL><P>
<A NAME="init">
<A NAME="DOC.1.4.29.1.9">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void init(const <!1><A HREF="GURL.html">GURL</A> &amp; url, <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>&gt; port=0, <!1><A HREF="DjVuFileCache.html">DjVuFileCache</A> * cache=0)</B></TT>
<DD>Initializes the document.<P>Contrary to <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.4">start_init</A>(), which just starts the initialization
thread in a multi-threaded environment, this function does not
return until the initialization completes (either successfully or
not). Basically, it calls <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.4">start_init</A>() and then
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>().
<DL><DT><DD></DL><P>
<A NAME="is_init_complete">
<A NAME="DOC.1.4.29.1.10">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool is_init_complete(void) const </B></TT>
<DD>Returns <TT>TRUE</TT> if the initialization thread finished (does not
matter successfully or not). As soon as it happens, the document
becomes completely initialized and its every function should work
properly. Please refer to the description of <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function
and of the <TT>DjVuDocument</TT> class to learn about the initializing
stages.<P>To wait for the initialization to complete use
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>() function.<P>To query the initialization stage use get_flags() function.<P>To learn whether initialization was successful or not,
use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.11">is_init_ok</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.16">is_init_failed</A>().<P><B>Note:</B> In a single threaded application the initialization
completes before the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function returns. 
<DL><DT><DD></DL><P>
<A NAME="is_init_ok">
<A NAME="DOC.1.4.29.1.11">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool is_init_ok(void) const </B></TT>
<DD>Returns <TT>TRUE</TT> is the initialization thread finished successfully.<P>See <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.10">is_init_complete</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>()
for more details. 
<DL><DT><DD></DL><P>
<A NAME="set_needs_compression">
<A NAME="DOC.1.4.29.1.12">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void set_needs_compression(void)</B></TT>
<DD>Forces compression with the next save_as function. 
<DL><DT><DD></DL><P>
<A NAME="needs_compression">
<A NAME="DOC.1.4.29.1.13">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool needs_compression(void) const </B></TT>
<DD>Returns <TT>TRUE</TT> if there are uncompressed pages in this document. 
<DL><DT><DD></DL><P>
<A NAME="needs_rename">
<A NAME="DOC.1.4.29.1.14">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool needs_rename(void) const </B></TT>
<DD>Returns <TT>TRUE</TT> if this file must be renamed before saving. 
<DL><DT><DD></DL><P>
<A NAME="can_compress">
<A NAME="DOC.1.4.29.1.15">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool can_compress(void) const </B></TT>
<DD>Returns <TT>TRUE</TT> if this file must be renamed before saving. 
<DL><DT><DD></DL><P>
<A NAME="is_init_failed">
<A NAME="DOC.1.4.29.1.16">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool is_init_failed(void) const </B></TT>
<DD>Returns <TT>TRUE</TT> is the initialization thread failed.<P>See <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.10">is_init_complete</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>()
for more details. 
<DL><DT><DD></DL><P>
<A NAME="get_doc_type">
<A NAME="DOC.1.4.29.1.17">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int get_doc_type(void) const </B></TT>
<DD>If the document has already learnt its type, the function will
returns it: <TT>DjVuDocument::OLD_BUNDLED</TT> or
<TT>DjVuDocument::OLD_INDEXED</TT> or <TT>DjVuDocument::SINGLE_PAGE</TT> or
<TT>DjVuDocument:BUNDLED</TT> or <TT>DjVuDocument::INDIRECT</TT>. The first
two formats are obsolete. Otherwise (if the type is unknown yet),
<TT>UNKNOWN_TYPE</TT> will be returned.<P><B>Note:</B> To check the stage of the document initialization
use get_flags() or <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.10">is_init_complete</A>() functions. To
wait for the initialization to complete use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>().
For single threaded applications the initialization completes
before the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function returns. 
<DL><DT><DD></DL><P>
<A NAME="get_doc_flags">
<A NAME="DOC.1.4.29.1.18">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>long get_doc_flags(void) const </B></TT>
<DD>Returns the document flags. The flags describe the degree in which
the <TT>DjVuDocument</TT> object is initialized. Every time the flags
are changed, a <TT>notify_doc_flags_changed()</TT> notification is
distributed using the <!1><A HREF="DjVuPortcaster.html">DjVuPortcaster</A> communication
mechanism.<P><B>Note:</B> To wait for the initialization to complete use
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>(). For single threaded applications
the initialization completes before the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function
returns. 
<DL><DT><DD></DL><P>
<A NAME="is_bundled">
<A NAME="DOC.1.4.29.1.19">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool is_bundled(void) const </B></TT>
<DD>Returns <TT>TRUE</TT> if the document is in bundled format (either in
<TT>DjVuDocument::OLD_BUNDLED</TT> or <TT>DjVuDocument::BUNDLED</TT> formats). 
<DL><DT><DD></DL><P>
<A NAME="get_init_url">
<A NAME="DOC.1.4.29.1.28">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GURL.html">GURL</A> get_init_url(void) const </B></TT>
<DD>Returns the URL passed to the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function
<DL><DT><DD></DL><P>
<A NAME="get_init_data_pool">
<A NAME="DOC.1.4.29.1.20">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DataPool.html">DataPool</A>&gt;  get_init_data_pool(void) const </B></TT>
<DD>Returns data corresponding to the URL passed to the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>()
function.<P><B>Note:</B> The pointer returned is guaranteed to be non-<TT>ZERO</TT>
only after the <TT>DjVuDocument</TT> learns its type (passes through
the first stage of initialization process). Please refer to
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() for details. 
<DL><DT><DD></DL><P>
<A NAME="Accessing pages ">
<A NAME="DOC.1.4.29.1.21">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Accessing pages </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="get_pages_num">
<A NAME="DOC.1.4.29.1.21.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int get_pages_num(void) const </B></TT>
<DD>Returns the number of pages in the document. If there is still
insufficient information about the document structure (initialization
has not finished yet), <TT>1</TT> will be returned. Please refer to
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() for details. 
<DL><DT><DD></DL><P>
<A NAME="page_to_url">
<A NAME="DOC.1.4.29.1.21.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GURL.html">GURL</A> page_to_url(int page_num) const </B></TT>
<DD>Translates the page number to the full URL of the page. This URL
is "artificial" for the <EM>bundled</EM> formats and is obtained
by appending the page name to the document's URL honoring possible
<TT>;</TT> and <TT>?</TT> in it. Negative page number has a special meaning for
<TT>OLD_INDEXED</TT> documents: it points to the URL, which the
<TT>DjVuDocument</TT> has been initialized with. For other formats this
is the same as page <TT>0</TT>.<P>The function tries it best to map the page number to the URL.
Although, if the document structure has not been fully discovered
yet, an empty URL will be returned. Use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>()
to wait until the document initialization completes. Refer to
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() for details.<P>Depending on the document format, the function assumes, that there
is enough information to complete the request when:
<UL>
<LI> <TT>OLD_INDEXED</TT>: If <TT>page_num&lt;0</TT>, <TT>DOC_TYPE_KNOWN</TT> flag must
be set. Otherwise <TT>DOC_NDIR_KNOWN</TT> must be set.
<LI> <TT>OLD_BUNDLED</TT>: If <TT>page_num=0</TT>, <TT>DOC_DIR_KNOWN</TT> flag must
be set. Otherwise <TT>DOC_NDIR_KNOWN</TT> flag must be set.
<LI> <TT>INDIRECT</TT> and <TT>BUNDLED</TT>: <TT>DOC_DIR_KNOWN</TT> flag must be set.
</UL> 
<DL><DT><DD></DL><P>
<A NAME="url_to_page">
<A NAME="DOC.1.4.29.1.21.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int url_to_page(const <!1><A HREF="GURL.html">GURL</A> &amp; url) const </B></TT>
<DD>Translates the page URL back to page number. Returns <TT>-1</TT> if the
page is not in the document or the document's structure
has not been learnt yet.<P>Depending on the document format, the function starts working
properly as soon as:
<UL>
<LI> <TT>OLD_INDEXED</TT> and <TT>OLD_BUNDLED</TT> and <TT>SINGLE_PAGE</TT>:
<TT>DOC_NDIR_KNOWN</TT> is set
<LI> <TT>INDIRECT</TT> and <TT>BUNDLED</TT>: <TT>DOC_DIR_KNOWN</TT> is set.
</UL> 
<DL><DT><DD></DL><P>
<A NAME="id_to_url">
<A NAME="DOC.1.4.29.1.21.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GURL.html">GURL</A> id_to_url(const char * id) const </B></TT>
<DD>Translates the textual ID to the complete URL if possible.<P>Depending on the document format the translation is done in the
following way:
<UL>
<LI> For <TT>BUNDLED</TT> and <TT>INDIRECT</TT> documents the function
scans the <!1><A HREF="DjVmDir.html">DjVmDir</A> (the document directory) and
matches the ID against:
<OL>
<LI> File ID from the <!1><A HREF="DjVmDir.html">DjVmDir</A>
<LI> File name from the <!1><A HREF="DjVmDir.html">DjVmDir</A>
<LI> File title from the <!1><A HREF="DjVmDir.html">DjVmDir</A>
</OL>
Then for <TT>BUNDLED</TT> document the URL is obtained by
appending the <TT>name</TT> of the found file to the document's
URL.<P>For <TT>INDIRECT</TT> documents the URL is obtained by
appending the <TT>name</TT> of the found file to the URL of
the directory containing the document.
<LI> For <TT>OLD_BUNDLED</TT> documents the function compares the ID
with internal name of every file inside the bundle and
composes an artificial URL by appending the file name to
the document's URL.
<LI> For <TT>OLD_INDEXED</TT> or <TT>SINGLE_PAGE</TT> documents the function
composes the URL by appending the ID to the URL of the
directory containing the document.
</UL><P>If information obtained by the initialization thread is not
sufficient yet, the
Depending on the document type, the information is sufficient when
<UL>
<LI> <TT>BUNDLED</TT> and <TT>INDIRECT</TT>: <TT>DOC_DIR_KNOWN</TT> flag is set.
<LI> <TT>OLD_BUNDLED</TT> and <TT>OLD_INDEXED</TT> and <TT>SINGLE_PAGE</TT>:
<TT>DOC_TYPE_KNOWN</TT> flag is set.
</UL> 
<DL><DT><DD></DL><P>
<A NAME="get_page">
<A NAME="DOC.1.4.29.1.21.5">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuImage.html">DjVuImage</A>&gt;  get_page(int page_num, bool sync=true, <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * port=0)</B></TT>
<DD>Returns <!1><A HREF="GP.html">GP</A> pointer to <!1><A HREF="DjVuImage.html">DjVuImage</A> corresponding to page
<TT>page_num</TT>. If caching is enabled, and there is a <EM>fully decoded</EM>
<!1><A HREF="DjVuFile.html">DjVuFile</A> in the cache, the image will be reused and will
be returned fully decoded. Otherwise, if multi-threaded behavior
is allowed, and <TT>sync</TT> is set to <TT>FALSE</TT>, the decoding will be
started in a separate thread, which enables to do progressive
redisplay. Thus, in this case the image returned may be partially
decoded.<P>Negative <TT>page_num</TT> has a special meaning for the <EM>old indexed</EM>
multipage documents: the <TT>DjVuDocument</TT> will start decoding of the
URL with which it has been initialized. For other formats page
<TT>-1</TT> is the same as page <TT>0</TT>.<P><TT>DjVuDocument</TT> can also connect the created page to the specified
<TT>port</TT> <EM>before starting decoding</EM>. This option will allow
the future owner of <!1><A HREF="DjVuImage.html">DjVuImage</A> to receive all messages and
requests generated during its decoding.<P>If this function is called before the document's structure becomes
known (the initialization process completes), the <!1><A HREF="DjVuFile.html">DjVuFile</A>,
which the returned image will be attached to, will be assigned a
temporary artificial URL, which will be corrected as soon as enough
information becomes available. The trick prevents the main thread
from blocking and in some cases helps to start decoding earlier.
The URL is corrected and decoding will start as soon as
<TT>DjVuDocument</TT> passes some given stages of initialization and
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.2">page_to_url</A>(), <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.4">id_to_url</A>() functions start working
properly. Please look through their description for details.<P><B>Note:</B> To wait for the initialization to complete use
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>(). For single threaded applications
the initialization completes before the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function
returns.<P>
<DL><DT><DT><B>Parameters:</B><DD><B>page_num</B> -  Number of the page to be decoded
<BR><B>sync</B> -  When set to <TT>TRUE</TT> the function will not return
until the page is completely decoded. Otherwise,
in a multi-threaded program, this function will
start decoding in a new thread and will return
a partially decoded image. Refer to
<!1><A HREF="DjVuImage.html#DOC.1.4.31.1.14.1">wait_for_complete_decode</A>() and
<!1><A HREF="DjVuFile.html#DOC.1.4.27.1.6.6">is_decode_ok</A>().
<BR><B>port</B> -  A pointer to <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A>, that the created image
will be connected to. <BR><DD></DL><P>
<A NAME="get_page">
<A NAME="DOC.1.4.29.1.21.6">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuImage.html">DjVuImage</A>&gt;  get_page(const char * id, bool sync=true, <!1><A HREF="DjVuPort.html#DOC.1.4.26.1.2">DjVuPort</A> * port=0)</B></TT>
<DD>Returns <!1><A HREF="GP.html">GP</A> pointer to <!1><A HREF="DjVuImage.html">DjVuImage</A> corresponding to the
specified ID. This function behaves exactly as the <TT>get_page()</TT>
function above. The only thing worth mentioning here is how the <TT>ID</TT>
parameter is treated.<P>First of all the function checks, if the ID contains a number.
If so, it just calls the <TT>get_page()</TT> function above. If ID is
<TT>ZERO</TT> or just empty, page number <TT>-1</TT> is assumed. Otherwise
the ID is translated to the URL using <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.4">id_to_url</A>(). 
<DL><DT><DD></DL><P>
<A NAME="get_djvu_file">
<A NAME="DOC.1.4.29.1.21.7">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuFile.html">DjVuFile</A>&gt;  get_djvu_file(int page_num, bool dont_create=false)</B></TT>
<DD>Returns <!1><A HREF="DjVuFile.html">DjVuFile</A> corresponding to the specified page.
Normally it translates the page number to the URL using
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.2">page_to_url</A>() and then creates <!1><A HREF="DjVuFile.html">DjVuFile</A> initializing
it with data from the URL.<P>The behavior becomes different, though in the case when the
document structure is unknown at the moment this function is called.
In this situations it invents a temporary URL, creates a
<!1><A HREF="DjVuFile.html">DjVuFile</A>, initializes it with this URL and returns
immediately. The caller may start decoding the file right away
(if necessary). The decoding will block but will automatically
continue as soon as enough information is collected about the
document. This trick should be quite transparent to the user and
helps to prevent the main thread from blocking. The decoding will
unblock and this function will stop using this "trick" as soon
as <TT>DjVuDocument</TT> passes some given stages of initialization and
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.2">page_to_url</A>(), <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.4">id_to_url</A>() functions start working
properly.<P>If <TT>dont_create</TT> is <TT>FALSE</TT> the function will return the file
only if it already exists.<P><B>Note:</B> To wait for the initialization to complete use
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.22">wait_for_complete_init</A>(). For single threaded applications
the initialization completes before the <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>() function
returns. 
<DL><DT><DD></DL><P>
<A NAME="get_djvu_file">
<A NAME="DOC.1.4.29.1.21.8">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuFile.html">DjVuFile</A>&gt;  get_djvu_file(const char * id, bool dont_create=false)</B></TT>
<DD>Returns <!1><A HREF="DjVuFile.html">DjVuFile</A> corresponding to the specified ID.
This function behaves exactly as the <TT>get_djvu_file()</TT> function
above. The only thing worth mentioning here is how the <TT>ID</TT>
parameter is treated.<P>First of all the function checks, if the ID contains a number.
If so, it just calls the <TT>get_djvu_file()</TT> function above. If ID is
<TT>ZERO</TT> or just empty, page number <TT>-1</TT> is assumed. Otherwise
the ID is translated to the URL using <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.21.4">id_to_url</A>().<P>If <TT>dont_create</TT> is <TT>FALSE</TT> the function will return the file
only if it already exists. 
<DL><DT><DD></DL><P>
<A NAME="get_thumbnail">
<A NAME="DOC.1.4.29.1.21.9">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   <!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DataPool.html">DataPool</A>&gt;  get_thumbnail(int page_num, bool dont_decode)</B></TT>
<DD>Returns a <!1><A HREF="DataPool.html">DataPool</A> containing one chunk <TT>TH44</TT> with
the encoded thumbnail for the specified page. The function
first looks for thumbnails enclosed into the document and if
it fails to find one, it decodes the required page and creates
the thumbnail on the fly (unless <TT>dont_decode</TT> is true).<P><B>Note:</B> It may happen that the returned <!1><A HREF="DataPool.html">DataPool</A> will
not contain all the data you need. In this case you will need
to install a trigger into the <!1><A HREF="DataPool.html">DataPool</A> to learn when the
data actually arrives. 
<DL><DT><DD></DL><P></DL>

<A NAME="wait_for_complete_init">
<A NAME="DOC.1.4.29.1.22">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>bool wait_for_complete_init(void)</B></TT>
<DD>Waits until the document initialization process finishes.
It can finish either successfully or not. Use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.11">is_init_ok</A>()
and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.16">is_init_failed</A>() to learn the result code.<P>As described in <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.4">start_init</A>(), for multi-threaded applications the
initialization is carried out in parallel with the main thread.
This function blocks the calling thread until the initializing
thread reads enough data, receives information about the document
format and exits.  This function returns <TT>true</TT> if the
initialization is successful. You can use get_flags() or
<!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.10">is_init_complete</A>() to check more precisely the degree of
initialization. Use <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.8">stop_init</A>() to interrupt initialization. 
<DL><DT><DD></DL><P>
<A NAME="wait_get_pages_num">
<A NAME="DOC.1.4.29.1.23">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>int wait_get_pages_num(void)</B></TT>
<DD>Wait until we known the number of pages and return. 
<DL><DT><DD></DL><P>
<A NAME="get_cache">
<A NAME="DOC.1.4.29.1.29">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="DjVuFileCache.html">DjVuFileCache</A>* get_cache(void) const </B></TT>
<DD>Returns cache being used.
<DL><DT><DD></DL><P>
<A NAME="Saving document to disk ">
<A NAME="DOC.1.4.29.1.24">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B> Saving document to disk </B></TT>
<DL><DT><DD></DL><P><DL>

<A NAME="get_djvm_doc">
<A NAME="DOC.1.4.29.1.24.1">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVmDoc.html">DjVmDoc</A>&gt;  get_djvm_doc(void)</B></TT>
<DD>Returns pointer to the <!1><A HREF="DjVmDoc.html">DjVmDoc</A> class, which can save the
document contents on the hard disk in one of the two new formats:
<EM>bundled</EM> and <EM>indirect</EM>. You may also want to look
at <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.24.2">write</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.24.3">expand</A>() if you are interested in
how to save the document.<P><B>Plugin Warning</B>. This function will read contents of the whole
document. Thus, if you call it from the main thread (the thread,
which transfers data from Netscape), the plugin will block. 
<DL><DT><DD></DL><P>
<A NAME="write">
<A NAME="DOC.1.4.29.1.24.2">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void write(<!1><A HREF="ByteStream.html">ByteStream</A> &amp; str, bool force_djvm=false)</B></TT>
<DD>Saves the document in the <EM>new bundled</EM> format. All the data
is "bundled" into one file and this file is written into the
passed stream.<P>If <TT>force_djvm</TT> is <TT>TRUE</TT> then even one page documents will be
saved in the <TT>DJVM BUNDLED</TT> format (inside a <TT>FORM:DJVM</TT>);<P><B>Plugin Warning</B>. This function will read contents of the whole
document. Thus, if you call it from the main thread (the thread,
which transfers data from Netscape), the plugin will block. 
<DL><DT><DD></DL><P>
<A NAME="expand">
<A NAME="DOC.1.4.29.1.24.3">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>void expand(const char * dir_name, const char * idx_name)</B></TT>
<DD>Saves the document in the <EM>new indirect</EM> format when every
page and component are stored in separate files. This format
is ideal for web publishing because it allows direct access to
any page and component. In addition to it, a top-level file
containing the list of all components will be created. To view
the document later in the plugin or in the viewer one should
load the top-level file.<P><B>Plugin Warning</B>. This function will read contents of the whole
document. Thus, if you call it from the main thread (the thread,
which transfers data from Netscape), the plugin will block.<P>
<DL><DT><DT><B>Parameters:</B><DD><B>dir_name</B> -  - Name of the directory which the document should
be expanded into.
<BR><B>idx_name</B> -  - Name of the top-level file containing the document
directory (basically, list of all files composing the document).<BR><DD></DL><P>
<A NAME="save_as">
<A NAME="DOC.1.4.29.1.24.4">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   void save_as(const char where[], const bool bundled=0)</B></TT>
<DD>This function can be used instead of <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.24.2">write</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.24.3">expand</A>().
It allows to save the document either in the new <TT>BUNDLED</TT> format
or in the new <TT>INDIRECT</TT> format depending on the value of parameter
<TT>bundled</TT>.<P>Depending on the document's type, the meaning of <TT>where</TT> is:
<UL>
<LI> For <TT>BUNDLED</TT> documents this is the name of the file
<LI> For <TT>INDIRECT</TT> documents this is the name of top-level
index file. All document files will be saved into the
save directory where the index file will resize. 
<DL><DT><DD></DL><P></DL>

<A NAME="get_djvm_dir">
<A NAME="DOC.1.4.29.1.25">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVmDir.html">DjVmDir</A>&gt;  get_djvm_dir(void) const </B></TT>
<DD>Returns pointer to the internal directory of the document, if it
is in one of the new formats: <TT>BUNDLED</TT> or <TT>INDIRECT</TT>.
Otherwise (if the format of the input document is obsolete),
<TT>ZERO</TT> is returned.<P><TT>ZERO</TT> will also be returned if the initializing thread has not
learnt enough information about the document (<TT>DOC_DIR_KNOWN</TT> has
not been set yet). Check <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.10">is_init_complete</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>()
for details. 
<DL><DT><DD></DL><P>
<A NAME="get_djvm_dir0">
<A NAME="DOC.1.4.29.1.26">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVmDir0.html">DjVmDir0</A>&gt;  get_djvm_dir0(void) const </B></TT>
<DD>Returns pointer to the internal directory of the document, if it
is in obsolete <TT>OLD_BUNDLED</TT> format.<P><TT>ZERO</TT> will also be returned if the initializing thread has not
learnt enough information about the document (<TT>DOC_DIR_KNOWN</TT> has
not been set yet). Check <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.10">is_init_complete</A>() and <!1><A HREF="DjVuDocument.html#DOC.1.4.29.1.9">init</A>()
for details. 
<DL><DT><DD></DL><P>
<A NAME="get_nav_dir">
<A NAME="DOC.1.4.29.1.27">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B><!1><A HREF="GP.html">GP</A>&lt;<!1><A HREF="DjVuNavDir.html">DjVuNavDir</A>&gt;  get_nav_dir(void) const </B></TT>
<DD>Returns pointer to <EM>navigation directory</EM> of the document.
The navigation directory is a DjVu file containing only one
chunk <TT>NDIR</TT> inside a <TT>FORM:DJVI</TT> with the list of all
document pages. 
<DL><DT><DD></DL><P>
<A NAME="inherits">
<A NAME="DOC.1.4.29.1.30">
<DT><IMG ALT="o" BORDER=0 SRC=icon2.gif><TT><B>virtual   bool inherits(const char * class_name) const </B></TT>
<DD>Returns TRUE if <TT>class_name</TT> is <TT>&quot;DjVuDocument&quot;</TT> or <TT>&quot;DjVuPort&quot;</TT>
<DL><DT><DD></DL><P></DL>
<HR>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="DjVuDocEditor.html">DjVuDocEditor</A><BR>
</DL>

<DL><DT><DD></DL><P><I><A HREF="index.html">Alphabetic index</A></I> <I><A HREF="HIER.html">HTML hierarchy of classes</A> or <A HREF="HIERjava.html">Java</A></I><P><HR>
<!-- This is were the DOC++ footer is defined  -->

<font face="arial,helvetica" size="2">
<a href=http://www.lizardtech.com>DjVu</a> is a trademark of LizardTech, Inc.  
<br>All other products mentioned are registered trademarks or trademarks of
their respective companies.
</font>
